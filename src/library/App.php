<?php

declare(strict_types=1);

namespace App\Ebcms\BookAdmin;

use DiggPHP\Framework\AppInterface;
use PDO;

class App implements AppInterface
{

    public static function onInstall()
    {
        $sql = self::getInstallSql();
        step1:
        fwrite(STDOUT, "是否安装演示数据？[yes,no]：");
        switch (trim((string) fgets(STDIN))) {
            case 'yes':
                fwrite(STDOUT, "安装演示数据\n");
                $sql .= PHP_EOL . self::getDemoSql();
                break;

            case 'no':
                fwrite(STDOUT, "不安装演示数据\n");
                break;

            default:
                goto step1;
                break;
        }
        self::execSql($sql);
    }

    public static function onUninstall()
    {
        $sql = '';
        step2:
        fwrite(STDOUT, "是否删除数据库？[yes,no]：");
        switch (trim((string) fgets(STDIN))) {
            case 'yes':
                fwrite(STDOUT, "删除数据库\n");
                $sql .= PHP_EOL . self::getUninstallSql();
                break;
            case 'no':
                fwrite(STDOUT, "不删除数据库\n");
                break;

            default:
                goto step2;
                break;
        }
        self::execSql($sql);
    }

    private static function execSql(string $sql)
    {
        $sqls = array_filter(explode(";" . PHP_EOL, $sql));

        $prefix = 'prefix_';
        $cfg_file = getcwd() . '/config/database.php';
        $cfg = (array)include $cfg_file;
        if (isset($cfg['master']['prefix'])) {
            $prefix = $cfg['master']['prefix'];
        }

        $dbh = new PDO("{$cfg['master']['database_type']}:host={$cfg['master']['server']};dbname={$cfg['master']['database_name']}", $cfg['master']['username'], $cfg['master']['password']);

        foreach ($sqls as $sql) {
            $dbh->exec(str_replace('prefix_', $prefix, $sql . ';'));
        }
    }

    private static function getInstallSql(): string
    {
        return <<<'str'
DROP TABLE IF EXISTS `prefix_ebcms_book_book`;
CREATE TABLE `prefix_ebcms_book_book` (
    `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '节点ID',
    `title` varchar(255) NOT NULL DEFAULT '' COMMENT '标题',
    `name` varchar(255) NOT NULL DEFAULT '' COMMENT '名称',
    `keywords` varchar(255) NOT NULL DEFAULT '' COMMENT '关键字',
    `description` varchar(255) NOT NULL DEFAULT '' COMMENT '简介',
    `tpl_book` varchar(255) NOT NULL DEFAULT '' COMMENT '模板',
    `tpl_post` varchar(255) NOT NULL DEFAULT '' COMMENT '内容页模板',
    `state` tinyint(3) unsigned NOT NULL DEFAULT '1' COMMENT '是否发布 1发布 2未发布',
    `body` text,
    `cover` varchar(255) NOT NULL DEFAULT '' COMMENT '封面',
    `create_time` int(10) unsigned NOT NULL DEFAULT '0',
    `update_time` int(10) unsigned NOT NULL DEFAULT '0',
    PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=COMPACT COMMENT='内容栏目表';
DROP TABLE IF EXISTS `prefix_ebcms_book_post`;
CREATE TABLE `prefix_ebcms_book_post` (
    `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '节点ID',
    `book_id` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '分类id',
    `pid` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '分类id',
    `type` tinyint(3) unsigned NOT NULL DEFAULT '1' COMMENT '1 目录 2文档',
    `title` varchar(255) NOT NULL DEFAULT '' COMMENT '标题',
    `keywords` varchar(255) NOT NULL DEFAULT '' COMMENT '关键词',
    `description` varchar(255) NOT NULL DEFAULT '' COMMENT '摘要',
    `body` text,
    `click` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '点击量',
    `create_time` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '操作时间',
    `update_time` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '更新时间',
    `state` tinyint(3) unsigned NOT NULL DEFAULT '1' COMMENT '状态 1发布 2未发布',
    `rank` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '点击量',
    PRIMARY KEY (`id`) USING BTREE,
    KEY `list` (`book_id`,`state`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=COMPACT COMMENT='内容基本表';
str;
    }

    private static function getDemoSql(): string
    {
        return <<<'str'
INSERT INTO `prefix_ebcms_book_book` (`id`, `title`, `name`, `keywords`, `description`, `tpl_book`, `tpl_post`, `state`, `body`, `cover`, `create_time`, `update_time`) VALUES
(1, 'ebcms/framework 手册', 'ebcms_framework', '', '', '', '', 1, '## 写在最前\r\n\r\n很多人好奇，全球那么多php框架，为什么还要重复造轮子？\r\n\r\n本人从事php开发超过5年，用过很多的框架，thinkphp、laravel、zendframework...，也用过很多成熟的基于php开发的产品，比如wordpress、discuz、phpcms、dedecms...，但总是这里或者哪里不让我如意的地方。\r\n\r\n**我心中理想的框架应该具备：**\r\n\r\n- 标准化：常用的操作、通用的类库，应该遵守统一的规范或接口\r\n- 应用生态：应该有很好的应用分享机制\r\n- 国际化：世界各地的开发者都能够无缝参与进来\r\n\r\n于是ebcms/framework出来了\r\n\r\n## 项目特点\r\n\r\n#### 1.严格遵守PSR规范\r\n\r\n本项目严格遵守PSR规范，`消息`、`日志`、`缓存`、`容器`、`事件`、`代码规范`...\r\n\r\n遵守PSR规范带来的直接好处是即刻拥有了composer上的海量的生态资源，并且更容易让其他php开发者无缝参与进来。\r\n\r\n#### 2.先进的应用生态理念\r\n\r\n本项目原生理念就是为应用分享，基于composer优秀的包依赖机制，您开发的APP可以通过composer被世界各地的人使用，您也可以使用别人开发的APP。\r\n\r\n#### 3.极简内核\r\n\r\n得益于遵守PSR规范，我们的内核极度简单，概括来讲就是`流程`+`路由`+`配置`，系统没有其他多余的东西，因为PSR已经帮我们规定好了，你只需要符合PSR规范。\r\n\r\n***项目开源地址：[Github](https://github.com/ebcms/framework)，欢迎PR ^_^***', '', 1595486640, 1611048000),
(2, 'jQuery手册', 'jquery', '', '', '', '', 1, '1', '/uploads/2020/08-23/5f41ddd96d46b.jpg', 1598097553, 1598152154),
(3, 'Redis手册', 'redis', '', '', '', '', 2, 'redis是缓存系统', '/uploads/2020/08-23/5f41de8b47183.jpg', 1598098337, 1611388107),
(4, 'PHP手册', 'php', '', '', '', '', 2, 'php是优秀的web开发语言，是全世界最好的语言', '/uploads/2020/08-23/5f41de9b6b858.jpg', 1598098357, 1611388108),
(5, '新营销革命', 'xyxgm', '', '', '', '', 2, '新营销革命', '/uploads/2020/08-23/5f41dee279131.jpg', 1598152404, 1598152448),
(6, '插件开发手册', 'plugin_manual', '', '', '', '', 1, '本插件开发手册适用于[EBCMS](https://www.ebcms.com)\r\n\r\n**手册写的并不详细，建议一边看插件源码一边学习**\r\n\r\n推荐一些简单的开源插件：\r\n\r\n- <https://github.com/xielei/plugin-cms-qiye> 一个简单的模板主题，学会了后就可以制作模板了\r\n- <https://github.com/xielei/plugin-page404> 一个简单的404页面，学会后可以灵活运用中间件\r\n- <https://github.com/xielei/plugin-manual> 手册系统，学习数据库操作，模板，模型，配置等等', '', 1610201301, 1614066670),
(7, '易贝内容管理系统', 'ebcms', '', '', '', '', 1, '易贝内容管理系统是基于EBCMS生态的管理系统发行版\r\n\r\n主要适用对象：\r\n\r\n* 文章站\r\n* 企业官网\r\n\r\n也可以通过插件系统扩展其他功能。\r\n\r\n欢迎加入官方QQ交流群：\r\n\r\n![官方QQ群](https://static.ebcms.com/img/qun.png)\r\n\r\n### 联系我们\r\n\r\n[官方网站：https://www.ebcms.com](https://www.ebcms.com)\r\n\r\n[开源地址：https://github.com/ebcms/project-ebcms](https://github.com/ebcms/project-ebcms)\r\n\r\n***坚决抵制盗版系统，维护健康网络环境！***\r\n', '', 1611384962, 1613741849),
(8, 'SwooleWorker开发手册', 'swooles-worker', '', '', '', '', 1, '# SwooleWorker 介绍\r\n\r\nSwooleWorker是基于swoole4开发的一款分布式长连接开发框架。\r\n\r\n[【开发文档】](http://www.xx.com) [【Github】](http://www.github.com)\r\n\r\n## 应用场景\r\n\r\n1. 推送\r\n2. 物联网\r\n3. IM\r\n4. 其他\r\n\r\n## 系统架构\r\n\r\n![http://www.ebcms.com/uploads/2021/04-27/6087c1f10c381.png](http://www.ebcms.com/uploads/2021/04-27/6087c1f10c381.png)\r\n\r\n我是一张图片\r\n\r\n基于经典的gateway worker架构，分布式部署，横向扩容。\r\n\r\n系统分为三块服务 Register服务 Gateway服务 Worker服务\r\n\r\nregister是通讯员，当gateway上线下线的时候，负责通知到worker，woker收到通知后就连接或断开与gateway之间的连接\r\n\r\ngateway负责维系客户端连接，当客户端有消息后转发客户端信息给worker，并且将worker执行结果转发给客户端\r\n\r\nworker接收gateway转发过来的请求，并执行工作任务\r\n\r\n## 安装\r\n\r\n只推荐composer方式安装，且确保您环境已经安装了swoole4\r\n\r\n``` bash\r\ncomposer require xielei/swoole-worker\r\n```\r\n\r\n## 基本接口\r\n\r\n* sendToClient(string $client, string $message)\r\n* sendToUid(string $uid, string $message)\r\n* sendToGroup(string $group, string $message, array $without_client_list = [])\r\n* sendToAll(string $message, array $without_client_list = [])\r\n* isOnline(string $client)\r\n* isUidOnline(string $uid): bool\r\n* getClientListByGroup(string $group, string $prev_client = null): iterable\r\n* getClientCount(): int\r\n* getClientCountByGroup(string $group): int\r\n* getClientList(string $prev_client = null): iterable\r\n* getClientListByUid(string $uid, string $prev_client = null): iterable\r\n* getClientInfo(string $client, int $type = 255): array\r\n* getUidListByGroup(string $group, bool $unique = true): iterable\r\n* getUidList(bool $unique = true): iterable\r\n* getUidCount(float $unique_percent = null): int\r\n* getGroupList(bool $unique = true): iterable\r\n* getUidCountByGroup(string $group): int\r\n* closeClient(string $client, bool $force = false)\r\n* bindUid(string $client, string $uid)\r\n* unBindUid(string $client)\r\n* joinGroup(string $client, string $group)\r\n* leaveGroup(string $client, string $group)\r\n* unGroup(string $group)\r\n* setSession(string $client, array $session)\r\n* updateSession(string $client, array $session)\r\n* deleteSession(string $client)\r\n* getSession(string $client): ?array\r\n* sendToAddressListAndRecv(array $items, float $timeout = 1): array\r\n* sendToAddressAndRecv(array $address, string $buffer, float $timeout = 1): string\r\n* sendToAddress(array $address, string $buffer, $timeout = 1)\r\n\r\n以上接口若不满足需求，还支持自定义命令~\r\n\r\n## 入门示例\r\n\r\n##### Register服务\r\n\r\n``` php\r\n<?php\r\n\r\nuse Xielei\\Swoole\\Register;\r\n\r\nrequire_once __DIR__ . \'/vendor/autoload.php\';\r\n\r\n$register = new Register(\'127.0.0.1\', 3327);\r\n$register->secret_key = \'this is secret_key..\';\r\n\r\n$register->start();\r\n```\r\n\r\n##### Gateway服务\r\n\r\n```php\r\n<?php\r\n\r\nuse Xielei\\Swoole\\Gateway;\r\n\r\nrequire_once __DIR__ . \'/vendor/autoload.php\';\r\n\r\n// 客户端连接地址\r\n$gateway = new Gateway(\'127.0.0.1\', 8000);\r\n\r\n// 供内部通讯的地址端口\r\n$gateway->lan_host = \'127.0.0.1\';\r\n$gateway->lan_port_start = 7777;\r\n\r\n// 注册中心 地址端口密钥\r\n$worker->register_host = \'127.0.0.1\';\r\n$worker->register_port = 3327;\r\n$gateway->register_secret_key = \'this is secret_key..\';\r\n\r\n$gateway->start();\r\n```\r\n\r\n##### Worker服务\r\n\r\n```php\r\n<?php\r\n\r\nuse Xielei\\Swoole\\Worker;\r\n\r\nrequire_once __DIR__ . \'/vendor/autoload.php\';\r\n\r\ninclude __DIR__ . \'/Event.php\';\r\n\r\n$worker = new Worker(new Event, 2);\r\n\r\n// 注册中心 地址端口密钥\r\n$worker->register_host = \'127.0.0.1\';\r\n$worker->register_port = 3327;\r\n$worker->register_secret_key = \'this is secret_key..\';\r\n\r\n$worker->start();\r\n```\r\n\r\n[【开发文档】](http://www.xx.com) [【Github】](http://www.github.com)\r\n', '', 1618924076, 1619515802);
INSERT INTO `prefix_ebcms_book_post` (`id`, `book_id`, `pid`, `type`, `title`, `keywords`, `description`, `body`, `click`, `create_time`, `update_time`, `state`, `rank`) VALUES
(1, 1, 12, 2, '流程', '', '', '系统流程执行如下：\r\n\r\n1. 入口文件`index.php`\r\n2. 载入文件`bootstrap.php`\r\n3. 执行钩子`app.start`\r\n4. 解析路由\r\n5. 执行钩子`app.start@包`\r\n6. 执行程序\r\n7. 执行钩子`app.end@包`\r\n8. 执行钩子`app.end`\r\n9. 结束\r\n\r\n`app.start`：系统开始解析路由之前\r\n\r\n`app.start@包`：路由解析完成后，此时可以得到请求的`包名`、`控制器名`\r\n\r\n`app.end@包`：此时系统已经完成执行，可以得到`响应`\r\n\r\n`app.end`：同上，只是`app.end@包`仅会在请求某个包的url下执行\r\n\r\n**特别说明**\r\n\r\n*若配置路由直接路由到闭包的时候，则不会执行相关包的钩子（即无5和7），因为没有经过包。*', 0, 1595486686, 1595733746, 1, 6),
(2, 1, 12, 2, '钩子', '', '', '**整个系统有且仅有四个钩子**\r\n\r\n* `app.start`\r\n* `app.start@包`\r\n* `app.end@包`\r\n* `app.end`\r\n\r\n钩子的作用主要是在系统执行到某个点的时候，进行切面操作，例如：\r\n\r\n* 在`app.start`的时候注册路由\r\n* 在`app.end`的时候操作`响应`\r\n* 在`app.start@包`的时候，对该包的执行进行一些配置\r\n\r\n钩子会自动载入包对应文件夹下的**所有文件**，如下：\r\n\r\n* /hook/钩子名/\\*\\*.php\r\n* /所有安装了的包/src/hook/钩子名/\\*\\*.php\r\n\r\n**可以跨包操作**\r\n\r\n例如在`xielei/manual`包下面配置钩子`/hook/app.start@xielei.test/foo.php`,`/hook/app.start@xielei.test/bar.php`文件夹，在文件加下的文件就会在**`xielei/test`**包执行的时候引入上述两个文件\r\n\r\n常见的使用场景如下：\r\n\r\n* 设置模板路径，做主题包\r\n* 对其他包做插件\r\n* ...\r\n\r\n**钩子示例**\r\n\r\n记录全局请求日志 `/hook/app.start/log.php`\r\n```php\r\nuse Ebcms\\App;\r\nuse Ebcms\\Container;\r\nuse Monolog\\Handler\\StreamHandler;\r\nuse Monolog\\Logger;\r\nuse Psr\\Log\\LoggerInterface;\r\n\r\nApp::getInstance()->execute(function (\r\n    Container $container,\r\n    App $app\r\n) {\r\n    $container->set(LoggerInterface::class, function () use ($app): LoggerInterface {\r\n        $log = new Logger($_SERVER[\'HTTP_HOST\']);\r\n        $log->pushHandler(new StreamHandler($app->getAppPath() . \'/runtime/log/\' . date(\'Y-m-d\') . \'/debug.log\', Logger::DEBUG));\r\n        return $log;\r\n    });\r\n    $container->get(LoggerInterface::class)->debug($_SERVER[\'REQUEST_METHOD\'] . \':\' . $_SERVER[\'REQUEST_URI\'], [$_POST, $_GET]);\r\n});\r\n```\r\n\r\n给`xielei/article`包自定义函数 `/hook/app.start@xielei.article/functions.php`\r\n```php\r\nfunction test(): array\r\n{\r\n    return [];\r\n}\r\n```\r\n\r\n给`xielei/article`包注入中间件 `/hook/app.start@xielei.article/middleware.php`\r\n```php\r\nuse Ebcms\\App;\r\nuse Ebcms\\RequestHandler;\r\n\r\nApp::getInstance()->execute(function (\r\n    RequestHandler $requestHandler,\r\n    App $app\r\n) {\r\n    $requestHandler->lazyMiddleware(SomeMiddleware::class);\r\n});\r\n```\r\n\r\n...还有很多，这里就不一一列举。', 0, 1595486693, 1595733753, 1, 5),
(3, 1, 12, 2, '配置', '', '', '**配置类`\\Ebcms\\Config`**\r\n\r\n配置分类三块：\r\n\r\n**用户配置**\r\n\r\n此配置位于系统的`config`文件夹下面，拥有最高的优先级，例如：\r\n\r\n`/config/xielei/article/site.php`\r\n\r\n**模块配置**\r\n\r\n模块配置有开发者事先配置，在对应包的`config`文件夹下面，例如：\r\n\r\n`包路径/src/config/site.php`\r\n\r\n**默认配置**\r\n\r\n默认配置是固定在代码中，无模块配置和用户配置的时候的默认值，例如：\r\n\r\n```php\r\n$config->get(\'key\',\'默认值\');\r\n$config->get(\'siteconfig@xielei.article\', [...]);\r\n$config->get(\'site.title@xielei.article\', \'某某网站\');\r\n```\r\n\r\n**优先级顺序**\r\n\r\n`用户配置`>`模块配置`>`默认配置`\r\n\r\n意思就是 在有用户配置的情况下会优先使用用户配置，否则就使用模块配置，若没有模块配置，再使用默认配置\r\n\r\n用法：\r\n\r\n```php\r\n$config->get(\'foo.bar@包\', \'默认值\');\r\n```\r\n\r\n例如：\r\n\r\n```php\r\n// 获取包xielei/article的配置文件site.php下的title值\r\n$config->get(\'site.title@xielei.article\');\r\n\r\n// 获取包xielei/article的配置文件site.php下的所有值\r\n$config->get(\'site@xielei/article\');\r\n```\r\n\r\n**只能获取已经安装的模块的配置数据**\r\n\r\n**包可以用`.`分割，也可以用`/`分割**', 0, 1595486703, 1595733760, 1, 4),
(4, 1, 12, 2, '中间件', '', '', '**中间件遵守标准的PSR规范！**\r\n\r\n中间件由`\\Ebcms\\RequestHandler`管理\r\n\r\n支持如下方法：\r\n\r\n* `middleware(MiddlewareInterface $middleware)` 注册一个中间件\r\n* `middlewares(array $middlewares)` 注册多个中间件\r\n* `prependMiddleware(MiddlewareInterface $middleware)` 注册一个中间件(顶部追加)\r\n* `lazyMiddleware(string $middleware)` 注册一个中间件(字符串形式、命名空间形式)\r\n* `lazyMiddlewares(array $middlewares)` 注册多个中间件(字符串形式、命名空间形式)\r\n* `lazyPrependMiddleware(string $middleware)` 注册一个中间件(字符串形式、命名空间形式)(顶部追加)\r\n\r\n**前置中间件**\r\n\r\n前置中间件就是在获得响应之前进行条件判断返回其他响应，主要是用作拦截，比如权限认证、跳转等等\r\n\r\n一个前置中间件的示例：\r\n\r\n```php\r\nuse Psr\\Http\\Message\\ResponseInterface;\r\nuse Psr\\Http\\Message\\ServerRequestInterface;\r\nuse Psr\\Http\\Server\\MiddlewareInterface;\r\nuse Psr\\Http\\Server\\RequestHandlerInterface;\r\n\r\nclass Auth implements MiddlewareInterface\r\n{\r\n    public function process(\r\n        ServerRequestInterface $request,\r\n        RequestHandlerInterface $handler\r\n    ): ResponseInterface {\r\n        if (\'未登录\') {\r\n            // 在响应之前返回跳转\r\n            return new JumpResponse(\'http://...\', 302);\r\n        }\r\n        return $handler->handle($request);\r\n    }\r\n}\r\n\r\n```\r\n\r\n**后置中间件**\r\n\r\n后置中间件主要是在获得响应后，对`响应`做变更，例如往响应的代码中注入代码，比如加入统计代码之类的。\r\n\r\n一个后置中间件的示例：\r\n\r\n```php\r\nuse Ebcms\\StreamFactory;\r\nuse Psr\\Http\\Message\\ServerRequestInterface;\r\nuse Psr\\Http\\Message\\ResponseInterface;\r\nuse Psr\\Http\\Server\\MiddlewareInterface;\r\nuse Psr\\Http\\Server\\RequestHandlerInterface;\r\n\r\nclass RejectTongjiCode implements MiddlewareInterface\r\n{\r\n\r\n    public function process(\r\n        ServerRequestInterface $request,\r\n        RequestHandlerInterface $handler\r\n    ): ResponseInterface {\r\n        $response = $handler->handle($request);\r\n        // 在响应之后，对响应注入其他代码\r\n        $tongji_code = \'<script>...</script>\';\r\n        $contents = str_replace(\'</body>\', $tongji_code . \'</body>\', $response->getBody());\r\n        return $response->withBody((new StreamFactory())->createStream($contents));\r\n    }\r\n}\r\n\r\n```\r\n\r\n*前置中间件和后置中间件的代码区别就是前置是在`$handler->handle($request)`处理之前返回其他`响应`，后置是在获取`$handler->handle($request)`响应之后对`响应`做出处理*\r\n\r\n**将中间件注入到系统**\r\n\r\n注入到系统中有很多方式，比如在钩子上注入，也可以在控制器中注入，也可以在路由上注入\r\n\r\n**通过钩子注入示例**\r\n\r\n```php\r\n// /hook/app.start/aaa.php\r\nuse Ebcms\\App;\r\nuse Ebcms\\RequestHandler;\r\n\r\nApp::getInstance()->execute(function (\r\n    RequestHandler $requestHandler\r\n) {\r\n    $requestHandler->lazyMiddleware(SomeMiddleware::class);\r\n});\r\n```\r\n\r\n**在控制器中注入示例**\r\n\r\n```php\r\nuse Ebcms\\RequestHandler;\r\n\r\nclass Index\r\n{\r\n    public function __construct(\r\n        RequestHandler $requestHandler\r\n    ) {\r\n        $requestHandler->lazyMiddleware(SomeMiddleware::class);\r\n    }\r\n}\r\n```', 0, 1595486714, 1595733767, 1, 3),
(5, 1, 12, 2, '路由', '', '', '**路由类`\\Ebcms\\Router`**\r\n\r\n**路由来自开源项目[ebcms/router](https://github.com/ebcms/router)，欢迎PR ^-^.**\r\n\r\n## 特性\r\n\r\n* 支持中间件绑定\r\n* 支持参数绑定\r\n* 支持静态路由\r\n* 支持分组路由\r\n* 支持正则路由\r\n* 支持可选参数\r\n* 支持地址生成\r\n\r\n## 注册路由\r\n\r\n方法如下：\r\n\r\n```php\r\n$router->getCollector()->get(\'/index\', Index::class);\r\n$router->getCollector()->post(\'/index\', Index::class);\r\n$router->getCollector()->delete(\'/index\', Index::class);\r\n$router->getCollector()->... \r\n```\r\n\r\n**支持`get`,`post`,`put`,`delete`,`patch`,`head`等方法。**\r\n\r\n## 路由分组\r\n\r\n另外也支持路由分组，例如：\r\n\r\n```php\r\n$router->getCollector()->addGroup(\'/group\', function($collector){\r\n	$collector->get(\'/path1\', ControlerA::class);\r\n	$collector->get(\'/path2\', ControllerB::class);\r\n	$collector->addGroup(\'/subgroup\', function($collector){\r\n		$collector->get(\'/subpath\', ControllerC::class);\r\n	});\r\n});\r\n```\r\n\r\n> 支持多级嵌套\r\n\r\n## 绑定中间件\r\n\r\n``` php\r\n// 单个绑定\r\n$router->getCollector()->get(\'/index\', Index::class, \'\', [\'middleware1\', \'middleware2\']);\r\n\r\n// 绑定到分组（该分组下所有的路由都会绑定）\r\n$router->getCollector()->addGroup(\'/group\', function($collector){\r\n	$collector->bindMiddlewares([\'somemiddleware1\', \'somemiddleware2\']);\r\n	$collector->get...\r\n});\r\n```\r\n\r\n## 绑定参数\r\n\r\n``` php\r\n// 单个绑定\r\n$router->getCollector()->get(\'/index\', Index::class, \'\', [], [\'somekey\'=>\'someval\']);\r\n\r\n// 绑定到分组（该分组下所有的路由都会绑定）\r\n$router->getCollector()->addGroup(\'/group\', function($collector){\r\n	$collector->bindParams([\'somekey\'=>\'someval\']);\r\n	$collector->get...\r\n});\r\n```\r\n\r\n## 路由命名\r\n\r\n``` php\r\n$router->getCollector()->get(\'/foo\', Index::class, \'/name1\');\r\n$router->getCollector()->get(\'/bar/{id:\\d+}\', Index::class, \'/name2\');\r\n$router->getCollector()->addGroup(\'/group\', function($collector){\r\n	$collector->get(\'/sub[/{id:\\d+}]\', Index::class, \'/name3\');\r\n});\r\n```\r\n\r\n## 地址生成\r\n\r\n*第一个参数填写路由到命名，参考上文提到的命名*\r\n\r\n`$router->build(\'/name1\')`就会生成`/foo`\r\n\r\n`$router->build(\'/name2\', [\'id\'=>333])`就会生成`/bar/333`\r\n\r\n`$router->build(\'/name3\')`就会生成`/group/sub`\r\n\r\n`$router->build(\'/name3\', [\'id\'=>122])`就会生成`/group/sub/122`\r\n\r\n## 默认路由\r\n\r\n上面讲的是自定义路由的情况，若是没有定义路由，系统会有默认路由，规则如下：\r\n\r\n`/包/路径`\r\n\r\n举例：\r\n\r\n* `/xielei/article/index` 路由到 `App\\Xielei\\Article\\Http\\Index`\r\n* `/xielei/article/admin/article/create` 路由到 `App\\Xielei\\Article\\Http\\Admin\\Article\\Create`\r\n* `/xielei/article/admin/create-category` 路由到 `App\\Xielei\\Article\\Http\\Admin\\CreateCategory`\r\n* `/xielei/my-demo/show-item` 路由到 `App\\Xielei\\MyDemo\\Http\\ShowItem`\r\n\r\n## 绑定域名\r\n\r\n示例代码如下：\r\n\r\n```php\r\n$router->getCollector()->addGroup(\'http://www.ebcms.com/sub\', function($collector){\r\n	$collector->get(\'/foo\', ControlerA::class,\'/name-1\');\r\n	$collector->addGroup(\'/sub2\', function($collector){\r\n		$collector->get(\'/cc\', ControllerC::class, \'/name-2\');\r\n		$collector->get(\'/cc/ddd.html\', ControllerC::class, \'/name-houzui\');\r\n	});\r\n});\r\n\r\n$router->build(\'/name-1\'); // http://www.ebcms.com/sub/foo\r\n\r\n$router->build(\'/name-2\'); // http://www.ebcms.com/sub/sub2/cc\r\n\r\n$router->build(\'/name-houzui\'); // http://www.ebcms.com/sub/sub2/cc/ddd.html\r\n```\r\n\r\n**通常，要是不绑定域名，不限制https或http的话 `http://www.ebcms.com/` 可以通过代码获取当前的域名而不必固定写死**\r\n', 0, 1595486720, 1596074011, 1, 2),
(6, 1, 12, 2, '依赖注入', '', '', '**容器类`\\Ebcms\\Container`**\r\n\r\n**依赖注入来自开源项目[ebcms/psr11](https://github.com/ebcms/psr11)，欢迎PR ^-^.**\r\n\r\n依赖注入的好处就是可以全局管理类，无须实例化直接获取。\r\n\r\n**自动实例化类**\r\n\r\n```php\r\nclass Bar\r\n{\r\n    public function __construct()\r\n    {\r\n    }\r\n}\r\n\r\nclass Foo\r\n{\r\n    public function __construct(Bar $bar)\r\n    {\r\n        $this->bar = $bar;\r\n    }\r\n    \r\n    public function getBar()\r\n    {\r\n        return $this->bar;\r\n    }\r\n}\r\n\r\n$foo = $container->get(Foo::class); //Foo\r\n$foo->getBar(); //Bar\r\n```\r\n\r\n而无须实例化Foo类，也不需要实例化Bar类，这一切都通过$container帮您完成。\r\n\r\n**默认的，执行的控制器的构造方法`__construct()`支持依赖注入，例如：**\r\n\r\n```php\r\nuse Ebcms\\App;\r\nuse Ebcms\\Config;\r\nuse Ebcms\\Router;\r\nuse Xielei\\Template;\r\n\r\nclass Index\r\n{\r\n    public function __construct(\r\n        App $app,\r\n        Router $router,\r\n        Config $config,\r\n        Template $template,\r\n        ...\r\n    ) {\r\n        $config->get(......);\r\n        $router->build(..);\r\n    }\r\n}\r\n```\r\n\r\n**通过容器获取的类支持依赖注入，例如：**\r\n\r\n```php\r\n$container->get(Foo::class);\r\n```\r\n\r\n那么 此处的Foo类的构造函数就可以依赖注入\r\n\r\n**通过`App::getInstrance()->execute(function(...){})`实现依赖注入，例如：**\r\n\r\n```php\r\nApp::getInstance()->execute(function (\r\n    App $app,\r\n    RequestHandler $requestHandler,\r\n    RequestFilter $input,\r\n    Router $router,\r\n    Config $config,\r\n    Template $template,\r\n    ....\r\n) {\r\n    $app->....\r\n});\r\n```\r\n', 0, 1595486816, 1595733793, 1, 1),
(7, 1, 12, 2, '说明', '', '', '为了文档的简洁，本文档对一些常用的、标准的术语或变量等作了简写，具体如下：\r\n\r\n## 系统\r\n\r\n| 变量      | 实体                | 备注 |\r\n| --------- | ------------------- | ---- |\r\n| `$app`    | `\\Ebcms\\App`实例    | 应用 |\r\n| `$router` | `\\Ebcms\\Router`实例 | 路由 |\r\n| `$config` | `\\Ebcms\\Config`实例 | 配置 |\r\n\r\n## Psr 标准\r\n\r\n| 变量               | 实体                                     | 备注     |\r\n| ------------------ | ---------------------------------------- | -------- |\r\n| `$uriFactory`      | 实现接口`UriFactoryInterface`的实例      | URI 工厂 |\r\n| `$responseFactory` | 实现接口`ResponseFactoryInterface`的实例 | 响应工厂 |\r\n| `$response`        | 实现接口`ResponseInterface`的实例        | 响应     |\r\n| `响应`             | 实现接口`ResponseInterface`的实例        |          |\r\n| `$container`       | 实现接口`ContainerInterface`的实例       | 容器     |\r\n| `$cache`           | 实现接口`CacheInterface`的实例           | 缓存     |\r\n| `$logger`          | 实现接口`LoggerInterface`的实例          | 日志     |\r\n| `$simplecache`     | 实现接口`SimpleCacheInterface`的实例     | 简单缓存 |\r\n| `$...`             | ...                                      | ...      |\r\n\r\n_还有很多，具体请看[PSR](https://www.php-fig.org/)官方文档_\r\n\r\n', 0, 1595488340, 1595733738, 1, 8),
(12, 1, 0, 1, '核心手册', '', '', NULL, 0, 1595665449, 1595665481, 1, 5),
(13, 1, 0, 1, '小试牛刀', '', '', NULL, 0, 1595665480, 1595855287, 1, 4),
(14, 1, 13, 2, '文件结构', '', '', '``` php\r\nxiao-wang\\hello-world\r\n├─library               类库目录\r\n│  ├─Http               控制器目录\r\n│  │  ├─Index.php       Index控制器\r\n│\r\n├─composer.json         composer 定义文件（此文件相当重要，必须要有）\r\n```\r\n\r\n这是这个包的目录结构，一共只有两个文件：\r\n\r\n* composer.json 包配置\r\n* Index.php 控制器\r\n', 0, 1595665524, 1595856848, 1, 3),
(15, 1, 13, 2, '包配置', '', '', '该包的composer.json配置文件如下：\r\n\r\n``` json\r\n{\r\n    \"name\": \"xiao-wang/hello-world\",\r\n    \"description\": \"小王的学习项目\",\r\n    \"type\": \"ebcms-app\", //该参数非常重要，必须要填写为ebcms-app\r\n    \"license\": \"MIT\",\r\n    \"require\": {\r\n        \"ebcms/framework\": \"1.*\"\r\n    },\r\n    \"autoload\": {\r\n        \"psr-4\": {\r\n            \"App\\\\XiaoWang\\\\HelloWorld\\\\\": \"src/library/\"\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**重点：**\r\n\r\n其中有一个重要配置项就是`type`，该参数必须填`ebcms-app`，ebcms会通过该参数判断这个包是否是ebcms的包，若判断是，则会注册，注册后，`config`以及`hook`里面的配置在需要的时候才会被读取，否则该包不会被认为是一个ebcms包，也无法通过`$config`读取其配置项，也不会执行相应的钩子。\r\n\r\n另外，此处定义了`App\\\\Xiaowang\\\\HelloWorld\\\\`命名空间的路径是`src/library/`，那么当访问/xiao-wang/hello-world/xxx的时候，就会路由到`App\\\\Xiaowang\\\\HelloWorld\\\\Http\\\\Xxx`控制器，这点很重要，当然，你也可以定义到其他目录。', 0, 1595665537, 1595856918, 1, 2),
(16, 1, 13, 2, '控制器文件', '', '', '```php\r\nnamespace App\\XiaoWang\\HelloWorld\\Http;\r\n\r\nclass Index\r\n{\r\n    public function handle()\r\n    {\r\n        return \'Hello World!\';\r\n    }\r\n}\r\n```\r\n\r\n**注意：**\r\n\r\n控制器必须要有一个handle方法，ebcms和其他系统不一样，ebcms是路由到控制器而不是路由到控制器中的方法，路由到控制器后规定了执行handle方法，handle方法直至自动注入。', 0, 1595665568, 1595857575, 1, 1),
(17, 1, 0, 1, '第二个APP(进阶)', '', '', NULL, 0, 1595665829, 1595733697, 2, 3),
(18, 1, 0, 1, '杂项', '', '', NULL, 0, 1595665833, 1595665837, 1, 0),
(19, 1, 18, 2, 'App全网发布', '', '', '访问[packagist.org](https://packagist.org/)，这是composer的官方仓库\r\n\r\n注册账户后，点击右上角的`submit`按钮，填入您的开源仓库地址（推荐使用[github](https://github.com)）,提交即可', 0, 1595665851, 1595738065, 1, 3),
(20, 1, 27, 2, '实现restful风格的控制器', '', '', '首先定义一个 trait\r\n\r\n``` php\r\nuse Ebcms\\App;\r\nuse Psr\\Http\\Message\\ResponseFactoryInterface;\r\nuse Psr\\Http\\Message\\ServerRequestInterface;\r\n\r\ntrait RestfulTrait\r\n{\r\n    final public function handle(\r\n        ServerRequestInterface $request,\r\n        ResponseFactoryInterface $response_factory\r\n    ) {\r\n        $method = strtolower($request->getMethod());\r\n        if (in_array($method, [\'get\', \'put\', \'post\', \'delete\', \'head\', \'patch\', \'options\']) && is_callable([$this, $method])) {\r\n            return App::getInstance()->execute([$this, $method]);\r\n        } else {\r\n            return $response_factory->createResponse(405);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n然后在需要的地方引入\r\n\r\n``` php\r\nuse Psr\\Http\\Message\\ResponseInterface;\r\n\r\nclass Demo\r\n{\r\n    use RestfulTrait;\r\n\r\n    public function get(\r\n        // ...\r\n    ): ResponseInterface {\r\n        return $responseFactory->createResponse(.....);\r\n    }\r\n\r\n    public function post(\r\n        // ...\r\n    ): ResponseInterface {\r\n        return $responseFactory->createResponse(.....);\r\n    }\r\n\r\n    public function delete(\r\n        // ...\r\n    ): ResponseInterface {\r\n        return $responseFactory->createResponse(.....);\r\n    }\r\n}\r\n```', 0, 1595665911, 1595737035, 1, 4),
(21, 1, 18, 2, '制作私有APP', '', '', NULL, 0, 1595666121, 1595666123, 1, 1),
(22, 1, 0, 1, '优秀APP推荐', '', '', NULL, 0, 1595670345, 1595670388, 1, 1),
(23, 1, 22, 2, 'xielei/manual 文档系统', '', '', '## 特点\r\n\r\n* 采用markdown书写\r\n* 多级目录\r\n* 搜索\r\n* 代码作色\r\n\r\n## 安装方式\r\n\r\n```\r\ncomposer require xielei/manual\r\n```\r\n\r\n***本文档即采用此系统***\r\n\r\n## 开源地址\r\n\r\n[Github](https://github.com/xielei/manual)', 0, 1595670367, 1595737361, 1, 3),
(24, 1, 22, 2, 'xielei/info 分类信息管理系统', '', '', '## 特点\r\n\r\n* 支持`单选`、`多选`、`范围`、`多属性`、`树型筛选`等多种筛选方式混合\r\n* 支持自定义字段\r\n\r\n## 安装方式\r\n\r\n..\r\n\r\n', 0, 1595670454, 1595737759, 1, 2),
(25, 1, 22, 2, 'xielei/article 文章管理系统', '', '', '## 特点\r\n\r\n* 简单，适合做文章站\r\n* 支持全文检索（无须其他扩展）\r\n\r\n## 安装方式\r\n\r\n``` bash\r\ncomposer require xielei/article\r\n```\r\n', 0, 1595670468, 1595737549, 1, 1),
(26, 1, 22, 2, 'xielei/installer 安装引导系统', '', '', '## 特点\r\n\r\n* ...\r\n\r\n## 安装方式\r\n\r\n```\r\ncomposer require xielei/installer\r\n```\r\n\r\n开源地址 [github](https://github.com/xiele/installer)', 0, 1595670569, 1595737838, 1, 0),
(27, 1, 0, 1, '代码参考', '', '', NULL, 0, 1595817521, 1596074481, 1, 2),
(28, 1, 27, 2, '自定义404页面', '', '', '自定义404可以通过中间件来实现，在响应之前，判断状态码，若是404，这返回一个自定义页面\r\n\r\n中间件代码：\r\n\r\n``` php\r\nuse Ebcms\\StreamFactory;\r\nuse Psr\\Http\\Message\\ServerRequestInterface;\r\nuse Psr\\Http\\Message\\ResponseInterface;\r\nuse Psr\\Http\\Server\\MiddlewareInterface;\r\nuse Psr\\Http\\Server\\RequestHandlerInterface;\r\n\r\nclass Page404 implements MiddlewareInterface\r\n{\r\n\r\n    public function process(\r\n        ServerRequestInterface $request,\r\n        RequestHandlerInterface $handler\r\n    ): ResponseInterface {\r\n        $response = $handler->handle($request);\r\n        if($response->getStatusCode() == 404){\r\n            $html = <<<\'html\'\r\n<h1>404</h1>\r\n<p>页面不存在~</p>\r\nhtml;\r\n            return $response->withBody((new StreamFactory())->createStream($html));\r\n        }\r\n        return $response;\r\n    }\r\n}\r\n```\r\n\r\n通过app.start将中间件注册到系统\r\n\r\n```\r\nuse Ebcms\\App;\r\nuse Ebcms\\RequestHandler;\r\n\r\nApp::getInstance()->execute(function (\r\n    RequestHandler $requestHandler,\r\n    App $app\r\n) {\r\n    $requestHandler->lazyMiddleware(Page404::class);\r\n});\r\n```', 0, 1595817557, 1596075625, 1, 5),
(29, 1, 12, 2, '包结构', '', '', 'ebcms的应用都是通过包发布的，一个包就是一个应用，一个包可以是私有的，也可以将包发布到composer上供他人使用。\r\n\r\n**这是推荐的包结构**\r\n\r\n``` php\r\n包结构\r\n├─tests                 单元测试\r\n│  ├─...                \r\n│\r\n├─config                配置目录\r\n│  ├─foo.php            一些配置文件\r\n│  ├─...                \r\n│\r\n├─hook                  钩子目录\r\n│  ├─app.start          app.start 挂载点\r\n│  │  ├─xxx.php         挂在的文件\r\n│  ├─app.start@包名     app.start@包名 挂载点\r\n│  ├─app.end@包名       app.end@包名 挂载点\r\n│  ├─app.end            app.end 挂载点\r\n│\r\n├─template              视图目录\r\n│  ├─...                \r\n│\r\n├─library               类库目录\r\n│  ├─Http               控制器\r\n│  ├─Model              模型\r\n│  ├─Middleware         中间件\r\n│  ├─Traits             Traits\r\n│  ├─...                \r\n│\r\n├─.gitignore            gitignore 定义文件\r\n├─composer.json         composer 定义文件（此文件相当重要，必须要有）\r\n├─LICENSE               授权说明文件\r\n├─README.md             README 文件\r\n```', 0, 1595856298, 1596289665, 1, 0),
(30, 1, 13, 2, '将包安装到系统', '', '', '包已经开发完毕，需要将包安装到ebcms上面。\r\n\r\n首先要创建工程：\r\n\r\n``` bash\r\ncomposer create-project ebcms/project\r\n```\r\n\r\n然后将刚刚开发的包安装到该工程上面。\r\n\r\n**EBCMS的包安装方式只有一种，那就是composer!!**\r\n\r\n你可以选择将包发布到[packagist.org](https://packagist.org)上面，然后通过：\r\n\r\n``` bash\r\ncomposer require xiao-wang/hello-world\r\n```\r\n\r\n也可以不发布直接本地安装，新建一个composer.json：\r\n\r\n``` json\r\n{\r\n    \"repositories\": [\r\n        {\r\n            \"type\": \"path\",\r\n            \"url\": \"E:\\\\你的包路径\\\\xiao-wang\\\\hello-world\"\r\n        }\r\n    ],\r\n}\r\n```\r\n\r\n然后执行\r\n\r\n``` bash\r\ncomposer require xiao-wang/hello-world\r\n```\r\n\r\n*当然，你也可以将你的仓库地址或者其他..加入到`repositories`配置里面，然后安装也可以，当然，这是composer的内容了，有兴趣可以去官网看看*\r\n\r\n现在该demo已经可以访问了 `http://xxxx/刚刚你的工程目录/public/index.php/xiao-wang/hello-world/index`', 0, 1595857639, 1596290326, 1, 0),
(31, 1, 27, 2, '自定义错误页面', '', '', '参考[自定义404页面](https://www.ebcms.com/manual/search/ebcms_framework?q=%E8%87%AA%E5%AE%9A%E4%B9%89404%E9%A1%B5%E9%9D%A2)', 0, 1596074474, 1596076092, 1, 3),
(32, 1, 27, 2, '记录请求日志', '', '', '将代码挂载到`app.start`即可\r\n\r\n若要记录某包的请求日志，挂载到`app.start@包`即可\r\n\r\n``` php\r\n// /hook/app.start/log.php\r\nuse Ebcms\\App;\r\nuse Ebcms\\Container;\r\nuse Monolog\\Handler\\StreamHandler;\r\nuse Monolog\\Logger;\r\nuse Psr\\Log\\LoggerInterface;\r\n\r\nApp::getInstance()->execute(function (\r\n    Container $container,\r\n    App $app\r\n) {\r\n    $container->set(LoggerInterface::class, function () use ($app): LoggerInterface {\r\n        $log = new Logger($_SERVER[\'HTTP_HOST\']);\r\n        $log->pushHandler(new StreamHandler($app->getAppPath() . \'/runtime/log/\' . date(\'Y-m-d\') . \'/debug.log\', Logger::DEBUG));\r\n        return $log;\r\n    });\r\n    $container->get(LoggerInterface::class)->debug($_SERVER[\'REQUEST_METHOD\'] . \':\' . $_SERVER[\'REQUEST_URI\'], [$_POST, $_GET]);\r\n});\r\n```', 0, 1596074551, 1596074679, 1, 2),
(33, 1, 27, 2, '创建自定义函数', '', '', '将代码挂载到`app.start`就能够创建全局函数\r\n\r\n若只要某特定包生效，这挂载到`app.start@包`即可\r\n\r\n``` php\r\nfunction test(): array\r\n{\r\n    return [];\r\n}\r\n```', 0, 1596074750, 1596074860, 1, 1),
(34, 1, 27, 2, '判断请求方式', '', '', '``` php\r\n/**\r\n * 判断是否为get请求\r\n *\r\n * @return bool\r\n */\r\nfunction is_get():bool\r\n{\r\n    return $_SERVER[\'REQUEST_METHOD\'] == \'GET\' ? true : false;\r\n}\r\n\r\n/**\r\n * 判断是否为post请求\r\n *\r\n * @return bool\r\n */\r\nfunction is_post():bool\r\n{\r\n    return $_SERVER[\'REQUEST_METHOD\'] == \'POST\' ? true : false;\r\n}\r\n\r\n/**\r\n * 判断是否为ajax请求\r\n *\r\n * @return bool\r\n */\r\nfunction is_ajax():bool\r\n{\r\n    return ((isset($_SERVER[\'HTTP_X_REQUESTED_WITH\']) && strtolower($_SERVER[\'HTTP_X_REQUESTED_WITH\']) == \'xmlhttprequest\')) ? true : false;\r\n}\r\n```', 0, 1596099765, 1596099823, 1, 0),
(35, 1, 12, 2, '目录结构', '', '', '这里是一个ebcms-framework推荐的工程目录结构。\r\n\r\n可以基于这个工程，安装其他应用包，例如文章系统 商城系统等等。\r\n\r\n具体请看[ebcms/project](https://github.com/ebcms/project)\r\n\r\n``` txt\r\n工程目录结构\r\n├─tests                  单元测试\r\n│  ├─...                \r\n│\r\n├─config                 配置目录\r\n│  │  ├─vendor_name      提供者\r\n│  │  │  ├─project_name  包名\r\n│  │  │  │  ├─foo.php    配置文件\r\n│  ├─...                \r\n│\r\n├─hook                   钩子目录\r\n│  ├─app.start           app.start 挂载点\r\n│  │  ├─xxx.php          挂在的文件\r\n│  ├─app.start@包名      app.start@包名 挂载点\r\n│  ├─app.end@包名        app.end@包名 挂载点\r\n│  ├─...                \r\n│  ├─app.end             app.end 挂载点\r\n│  ├─...                \r\n│\r\n├─public                 网站目录\r\n│  ├─index.php           入口文件\r\n│  ├─...                \r\n│\r\n├─vendor                 composer包目录\r\n│\r\n├─.gitignore             gitignore 定义文件\r\n├─composer.json          composer 定义文件（此文件相当重要，必须要有）\r\n├─LICENSE                授权说明文件\r\n├─README.md              README 文件\r\n```\r\n\r\n这只是一个最基本的项目结构，每个项目都由很多应用包组成，这些应用包可以是自己开发的，也可以是通过composer安装的别人开发的。', 0, 1596289477, 1596291197, 1, 7),
(36, 2, 0, 1, '核心', '', '', NULL, 0, 1598097603, 1598097683, 1, 10),
(37, 2, 0, 1, '属性', '', '', NULL, 0, 1598097613, 1598097684, 1, 9),
(40, 2, 0, 1, '文档处理', '', '', NULL, 0, 1598097644, 1598097685, 1, 8),
(41, 2, 0, 1, '筛选', '', '', NULL, 0, 1598097648, 1598097686, 1, 7),
(42, 2, 0, 1, '事件', '', '', NULL, 0, 1598097655, 1598097686, 1, 6),
(43, 2, 0, 1, '效果', '', '', NULL, 0, 1598097661, 1598097687, 1, 5),
(44, 2, 0, 1, 'AJAX', '', '', NULL, 0, 1598097664, 1598097687, 1, 4),
(45, 2, 0, 1, '工具', '', '', NULL, 0, 1598097671, 1598097687, 1, 3),
(46, 2, 0, 1, '事件对象', '', '', NULL, 0, 1598097681, 1598097688, 1, 2),
(47, 2, 0, 1, 'CSS', '', '', NULL, 0, 1598097704, 1598097717, 1, 1),
(48, 2, 0, 1, '选择器', '', '', NULL, 0, 1598097709, 1598097717, 1, 0),
(49, 2, 36, 1, '核心函数', '', '', NULL, 0, 1598097734, 1598097773, 1, 5),
(50, 2, 36, 1, '对象访问', '', '', NULL, 0, 1598097743, 1598097774, 1, 4),
(51, 2, 36, 1, '数据缓存', '', '', NULL, 0, 1598097747, 1598097774, 1, 3),
(52, 2, 36, 1, '队列控制', '', '', NULL, 0, 1598097755, 1598097774, 1, 2),
(53, 2, 36, 1, '插件机制', '', '', NULL, 0, 1598097758, 1598097775, 1, 1),
(54, 2, 36, 1, '多库共存', '', '', NULL, 0, 1598097772, 1598097775, 1, 0),
(55, 2, 49, 2, 'jQuery([selector,[context]])', '', '', '## 概述\r\n\r\n这个函数接收一个包含 CSS 选择器的字符串，然后用这个字符串去匹配一组元素。\r\n\r\njQuery 的核心功能都是通过这个函数实现的。 jQuery中的一切都基于这个函数，或者说都是在以某种方式使用这个函数。这个函数最基本的用法就是向它传递一个表达式（通常由 CSS 选择器组成），然后根据这个表达式来查找所有匹配的元素。\r\n\r\n默认情况下, 如果没有指定context参数，$()将在当前的 HTML document中查找 DOM 元素；如果指定了 context 参数，如一个 DOM 元素集或 jQuery 对象，那就会在这个 context 中查找。在jQuery 1.3.2以后，其返回的元素顺序等同于在context中出现的先后顺序。\r\n\r\n参考文档中 选择器 部分获取更多用于 expression 参数的 CSS 语法的信息。\r\n\r\n## 参数\r\n\r\nselector,[context]String,Element,/jQueryV1.0selector:用来查找的字符串\r\n\r\ncontext:作为待查找的 DOM 元素集、文档或 jQuery 对象。\r\n\r\nelementElementV1.0一个用于封装成jQuery对象的DOM元素\r\n\r\nobjectobjectV1.0一个用于封装成jQuery对象\r\n\r\nelementArrayElementV1.0一个用于封装成jQuery对象的DOM元素数组。\r\n\r\njQuery objectobjectV1.0一个用于克隆的jQuery对象。\r\n\r\njQuery()V1.4返回一个空的jQuery对象。\r\n\r\n## 示例\r\n\r\n描述:\r\n\r\n找到所有 p 元素，并且这些元素都必须是 div 元素的子元素。\r\n\r\njQuery 代码:\r\n\r\n``` javascript\r\n$(\"div > p\");\r\n```\r\n\r\n描述:\r\n\r\n设置页面背景色。\r\n\r\njQuery 代码:\r\n\r\n``` javascript\r\n$(document.body).css( \"background\", \"black\" );\r\n```\r\n\r\n描述:\r\n\r\n隐藏一个表单中所有元素。\r\n\r\njQuery 代码:\r\n\r\n``` javascript\r\n$(myForm.elements).hide()\r\n```\r\n\r\n描述:\r\n\r\n在文档的第一个表单中，查找所有的单选按钮(即: type 值为 radio 的 input 元素)。\r\n\r\njQuery 代码:\r\n\r\n``` javascript\r\n$(\"input:radio\", document.forms[0]);\r\n```\r\n\r\n描述:\r\n\r\n在一个由 AJAX 返回的 XML 文档中，查找所有的 div 元素。\r\n\r\njQuery 代码:\r\n\r\n``` javascript\r\n$(\"div\", xml.responseXML);\r\n```', 0, 1598097798, 1598098150, 1, 4),
(56, 2, 49, 2, 'jQuery(html,[ownerDocument])', '', '', NULL, 0, 1598097808, 1598097835, 1, 3),
(57, 2, 49, 2, 'jQuery(callback)', '', '', NULL, 0, 1598097817, 1598097836, 1, 2),
(58, 2, 49, 2, 'holdReady(hold)', '', '', NULL, 0, 1598097826, 1598098239, 1, 1),
(59, 2, 49, 2, 'each(callback)', '', '', NULL, 0, 1598097834, 1598098234, 1, 0),
(60, 6, 0, 2, '插件结构', '', '', '```\r\ndemo\r\n├── src                                 // 资源\r\n│   ├── config                      // 配置\r\n│   │   ├── foo.php                     // 配置文件\r\n│   │   └── xxx.php                      // 配置文件\r\n│   ├── hook\r\n│   │   ├── app.init              // 钩子\r\n│   │   │   ├── foo.php                //  钩子文件\r\n│   │   │   └── xxx.php               //  钩子文件\r\n│   │   ├── app.start            // 钩子\r\n│   │   │   ├── foo.php                // 钩子文件\r\n│   │   │   └── xxx.php                 //  钩子文件\r\n│   │   └── app.end             // 钩子\r\n│   │        ├── foo.php                //  钩子文件\r\n│   │        └── xxx.php                 //  钩子文件\r\n│   ├── library\r\n│   │   ├── Http                   // 控制器\r\n│   │   │   ├── Foo.php                //  访问控制器\r\n│   │   │   └── Xxx.php               //  访问控制器\r\n│   │   ├── Model                // 模型\r\n│   │   │   ├── Foo.php                // 模型文件\r\n│   │   │   └── Xxx.php                 //  模型文件\r\n│   │   ├── Middleware        // 中间件\r\n│   │   │   ├── Foo.php                // 中间件文件\r\n│   │   │   └── Xxx.php                 //  中间件文件\r\n│   │   └── Other                 // 其他\r\n│   │        ├── Foo.php                //  其他文件\r\n│   │        └── Xxx.php                 //  其他文件\r\n│   └── template                 // 模板\r\n│        ├── foo.php                     //  模板文件\r\n│        └── xxx.php                      //  模板文件\r\n├── plugin.json //插件描述文件(必须有)\r\n├── README.md //介绍文件\r\n└── CHANGELOG.md //更新日志\r\n```\r\n\r\n更多插件源码，供学习参考：[https://github.com/xielei](https://github.com/xielei)', 0, 1610203153, 1613616185, 1, 9),
(61, 6, 0, 2, '约定', '', '', '- 系统严格遵守[`PSR`](https://www.php-fig.org/)([中文翻译](https://learnku.com/docs/psr))各个规范，文档中说的`容器`、`响应`、`请求`等若无特别说明，均指的是规范中的实例\r\n- `$app`专指`\\Ebcms\\App`实例\r\n- `$config`专指`\\Ebcms\\Config`实例\r\n- `$router`专指`\\Ebcms\\Router`实例\r\n- `$container`专指`\\Ebcms\\Container`实例\r\n- `$template`专指`\\Ebcms\\Template`实例\r\n- `$hook`专指`\\Ebcms\\Hook`实例', 0, 1610203249, 1613612745, 1, 10),
(63, 6, 0, 2, '路由', '', '', '路由开源地址：[https://github.com/ebcms/router](https://github.com/ebcms/router)\r\n\r\n### 默认路由\r\n\r\n上面讲的是自定义路由的情况，若是没有定义路由，系统会有默认路由，规则如下：\r\n\r\n`/包/路径`\r\n\r\n举例：\r\n\r\n* `/plugin/demo/index` 路由到 `App\\Plugin\\Demo\\Http\\Index`\r\n* `/plugin/demo/admin/create` 路由到 `App\\Plugin\\Demo\\Http\\Admin\\Create`\r\n* `/plugin/demo/admin/create-category` 路由到 `App\\Plugin\\Demo\\Http\\Admin\\CreateCategory`\r\n* `/plugin/demo/show-item` 路由到 `App\\Plugin\\Demo\\Http\\ShowItem`\r\n\r\n### 路由规则\r\n\r\n插件的路由规则是：`网站/index.php/plugin/plugin_name/path..`\r\n\r\n**示例1**\r\n\r\n- 地址：`网站/index.php/plugin/demo/index`\r\n- 指向：`plugin/demo/src/library/Http/Index.php`\r\n\r\n**示例2**\r\n\r\n- 地址：`网站/index.php/plugin/demo/admin/login`\r\n- 指向：`plugin/demo/src/library/Http/Admin/Login.php`\r\n\r\n**示例3**\r\n\r\n- 地址：`网站/index.php/plugin/demo/admin/log-out`\r\n- 指向：`plugin/demo/src/library/Http/Admin/LogOut.php`\r\n\r\n### 地址生成器\r\n\r\n`$router->build(\'路由地址\')`\r\n\r\n**示例1**\r\n\r\n- 路由地址：`$router->build(\'/plugin/demo/index\')`\r\n- 生成结果：`http://..../index.php/plugin/demo/index`\r\n\r\n**示例2**\r\n\r\n- 路由地址：`$router->build(\'/plugin/demo/admin/log-out\')`\r\n- 生成结果：`http://..../index.php/plugin/demo/admin/log-out`\r\n\r\n### 路由美化\r\n\r\n可以通过自定义路由实现美化url\r\n\r\n示例：\r\n\r\n```php\r\n$router->getCollector()->addGroup(\'http://www.demo.com\', function (Ebcms\\Router\\Collector $collector) {\r\n    $collector->get(\'/\', \\App\\Plugin\\Demo\\Http\\Index::class);\r\n    $collector->get(\'/admin_login\', \\App\\Plugin\\Demo\\Http\\Admin\\Login::class);\r\n    $collector->get(\'/admin_logout\', \\App\\Plugin\\Demo\\Http\\Admin\\LogOut::class);\r\n});\r\n```\r\n\r\n> **注意：路由注册必须在路由解析之前完成，通常挂载到`app.init`上！！也就是在目录`/src/hook/app.init/`下面建一个文件放入上面的代码**\r\n\r\n通过上面的路由代码后，生成器生成的路由将会发生变化：\r\n\r\n**示例1**\r\n\r\n- 路由地址：`$router->build(\'/plugin/demo/index\')`\r\n- 生成结果：`http://www.demo.com/index.php/`\r\n\r\n**示例2**\r\n\r\n- 路由地址：`$router->build(\'/plugin/demo/admin/login\')`\r\n- 生成结果：`http://www.demo.com/index.php/admin_login`\r\n\r\n**示例3**\r\n\r\n- 路由地址：`$router->build(\'/plugin/demo/admin/log-out\')`\r\n- 生成结果：`http://www.demo.com/index.php/admin_logout`\r\n\r\n### 路由分组\r\n\r\n另外也支持路由分组，例如：\r\n\r\n```php\r\n$router->getCollector()->addGroup(\'/group\', function($collector){\r\n	$collector->get(\'/path1\', ControlerA::class);\r\n	$collector->get(\'/path2\', ControllerB::class);\r\n	$collector->addGroup(\'/subgroup\', function($collector){\r\n		$collector->get(\'/subpath\', ControllerC::class);\r\n	});\r\n});\r\n```\r\n\r\n> 支持多级嵌套\r\n\r\n### 绑定中间件\r\n\r\n``` php\r\n// 单个绑定\r\n$router->getCollector()->get(\'/index\', Index::class, \'\', [\'middleware1\', \'middleware2\']);\r\n\r\n// 绑定到分组（该分组下所有的路由都会绑定）\r\n$router->getCollector()->addGroup(\'/group\', function($collector){\r\n	$collector->bindMiddlewares([\'somemiddleware1\', \'somemiddleware2\']);\r\n	$collector->get...\r\n});\r\n```\r\n\r\n### 绑定参数\r\n\r\n``` php\r\n// 单个绑定\r\n$router->getCollector()->get(\'/index\', Index::class, \'\', [], [\'somekey\'=>\'someval\']);\r\n\r\n// 绑定到分组（该分组下所有的路由都会绑定）\r\n$router->getCollector()->addGroup(\'/group\', function($collector){\r\n	$collector->bindParams([\'somekey\'=>\'someval\']);\r\n	$collector->get...\r\n});\r\n```\r\n\r\n### 路由命名\r\n\r\n``` php\r\n$router->getCollector()->get(\'/foo\', Index::class, \'/name1\');\r\n$router->getCollector()->get(\'/bar/{id:\\d+}\', Index::class, \'/name2\');\r\n$router->getCollector()->addGroup(\'/group\', function($collector){\r\n	$collector->get(\'/sub[/{id:\\d+}]\', Index::class, \'/name3\');\r\n});\r\n```\r\n\r\n### 绑定域名\r\n\r\n示例代码如下：\r\n\r\n```php\r\n$router->getCollector()->addGroup(\'http://www.ebcms.com/sub\', function($collector){\r\n	$collector->get(\'/foo\', ControlerA::class,\'/name-1\');\r\n	$collector->addGroup(\'/sub2\', function($collector){\r\n		$collector->get(\'/cc\', ControllerC::class, \'/name-2\');\r\n		$collector->get(\'/cc/ddd.html\', ControllerC::class, \'/name-houzui\');\r\n	});\r\n});\r\n\r\n$router->build(\'/name-1\'); // http://www.ebcms.com/sub/foo\r\n\r\n$router->build(\'/name-2\'); // http://www.ebcms.com/sub/sub2/cc\r\n\r\n$router->build(\'/name-houzui\'); // http://www.ebcms.com/sub/sub2/cc/ddd.html\r\n```\r\n\r\n**通常，要是不绑定域名，不限制https或http的话 `http://www.ebcms.com/` 可以通过代码获取当前的域名而不必固定写死**\r\n\r\n### 去掉index.php\r\n\r\n配置伪静态可去掉index.php\r\n\r\n**nginx**\r\n\r\n```\r\nlocation / {  \r\n	try_files $uri $uri/ /index.php$is_args$query_string;  \r\n}  \r\n```\r\n\r\n**apache**\r\n\r\n```\r\n<IfModule mod_rewrite.c>\r\n  Options +FollowSymlinks -Multiviews\r\n  RewriteEngine On\r\n\r\n  RewriteCond %{REQUEST_FILENAME} !-d\r\n  RewriteCond %{REQUEST_FILENAME} !-f\r\n  RewriteRule ^(.*)$ index.php [QSA,PT,L,E=PATH_INFO:$1]\r\n</IfModule>\r\n```', 0, 1610246193, 1613973485, 1, 8),
(64, 6, 0, 2, '模板', '', '', '**模板类开源地址是<https://github.com/ebcms/library-template>**\r\n\r\n## 模板文件\r\n\r\n命名规则是\r\n\r\n``` php\r\n文件@分组\r\n```\r\n\r\n例如 `common/header@ebcms/admin` 是获取 `ebcms/admin` 分组下的 `common/header.php` 文件\r\n\r\n**一个分组可以注册多个路径**\r\n\r\n``` php\r\n$template->addPath(\'ebcms/admin\', \'./../template/\', 1);\r\n$template->addPath(\'ebcms/admin\', \'./../template2/\', 2);\r\n$template->addPath(\'ebcms/admin\', \'./../template3/\', 3);\r\n```\r\n\r\n这样，通过\r\n\r\n``` php\r\n$template->randerFromFile(\'common/header@ebcms/admin\');\r\n```\r\n\r\n就会从上面注册的三个路径中**按照优先级**去找对应的文件， `appPath` 的第三个参数是优先级，越大越优先，例如上面的代码就是会优先从 `./../template3/` 中寻找，找不到再到低优先级的路径中寻找，直到找到需要的模板，若找不到会抛出异常。\r\n\r\n**系统定义**\r\n\r\n系统已经将\r\n\r\n``` php\r\n./template/插件包/     优先级较高\r\n./plugin/插件包/src/template/   优先级较低\r\n```\r\n\r\n两个目录注册到了对应的分组，例如 `...@plugin/demo` 会依次在下面两个目录中寻找\r\n\r\n``` php\r\n/template/plugin/demo/\r\n/plugin/demo/src/template/\r\n```\r\n\r\n## 常用方法\r\n\r\n**渲染文件**\r\n\r\n``` php\r\n$template->randerFromFile(\'...@分组\');\r\n```\r\n\r\n**渲染字符串**\r\n\r\n``` php\r\n$template->randerFromString(\'现在是{:time()}\');\r\n```\r\n\r\n**分配变量**\r\n\r\n``` php\r\n// 方式1\r\n$template->assign(\'title\', \'标题\');\r\n$template->assign(\'name\', \'work\');\r\n\r\n// 方式2\r\n$template->assign([\r\n    \'title\'=>\'标题\',\r\n    \'name\'=>\'work\',\r\n]);\r\n\r\n// 方式3\r\n$template->randerFromString(\'现在是{:time()}\', [\r\n    \'title\'=>\'标题\',\r\n    \'name\'=>\'work\',\r\n]);\r\n$template->randerFromFile(\'...@分组\', [\r\n    \'title\'=>\'标题\',\r\n    \'name\'=>\'work\',\r\n]);\r\n```\r\n\r\n## 模板标签\r\n\r\n**原生标签**\r\n\r\n``` php\r\n// 方式1\r\n<?php echo 111;?>\r\n\r\n// 方式2\r\n{php}\r\necho 222;\r\n{/php}\r\n\r\n// 方式3\r\n{php echo 3}\r\n```\r\n\r\n**引入文件**\r\n\r\n``` php\r\n{include common/header@ebcms/admin}\r\n<h1>你好</h1>\r\n{include common/footer@ebcms/admin}\r\n```\r\n\r\n**变量**\r\n\r\n``` php\r\n{$title}\r\n{$item[\'title\']}\r\n{$item.body}\r\n```\r\n\r\n**foreach循环**\r\n\r\n``` php\r\n{foreach $arr as $key=>$item}\r\n\r\n{$item.title}\r\n{$item.body}\r\n{$item.click}\r\n...\r\n\r\n{/foreach}\r\n```\r\n\r\n**for循环**\r\n\r\n``` php\r\n{for $i=0; $i < 10; $i++}\r\n\r\n{$i}\r\n\r\n{/for}\r\n```\r\n\r\n**if判断**\r\n\r\n``` php\r\n{if $a==3}\r\n..\r\n{elseif $b==4}\r\n..\r\n{else}\r\n..\r\n{/if}\r\n```\r\n\r\n**switch选择**\r\n\r\n``` php\r\n{switch $b}\r\n{case 1}\r\n是1\r\n{/case}\r\n{case 2}\r\n是2\r\n{/case}\r\n{default}\r\n默认值\r\n{/default}\r\n{/switch}\r\n```\r\n\r\n**function函数**\r\n\r\n``` php\r\n// 定义函数\r\n{function test($a,$b=2)}\r\n<p>a:{$a}</p>\r\n<p>b:{$b}</p>\r\n{/function}\r\n\r\n// 执行函数\r\n{php echo test(2,33)}\r\n```\r\n\r\n**dump调试**\r\n\r\n``` php\r\n{dump $a}\r\n{dump $var}\r\n```\r\n\r\n**echo输出**\r\n\r\n``` php\r\n{echo 1+2}\r\n\r\n// 简写 用冒号\r\n{:1+2}\r\n```\r\n', 0, 1610246208, 1614065495, 1, 5),
(65, 6, 0, 2, '钩子', '', '', '钩子的作用主要是在系统执行到某个点的时候，进行切面操作\r\n\r\n**整个系统有四个钩子**\r\n\r\n* `app.init` 系统初始化\r\n* `app.start` 路由完成，已经知道当前请求的目标（插件，控制器）\r\n* `app.start@包` 例如`app.start@plugin.demo`\r\n* `app.end@包` 例如`app.end@plugin.demo`\r\n* `app.end` 执行完毕\r\n\r\n钩子会自动载入包对应文件夹下的**所有文件**，如下：\r\n\r\n* /hook/钩子名/\\*\\*.php\r\n* /所有安装了的包/src/hook/钩子名/\\*\\*.php\r\n\r\n**可以跨包操作**\r\n\r\n例如在`plugin/demo`包下面配置钩子`/hook/app.start@plugin.demo/foo.php`,`/hook/app.start@plugin.demo/bar.php`文件夹，在文件加下的文件就会在**`plugin/demo`**包执行的时候引入上述两个文件\r\n\r\n常见的使用场景如下：\r\n\r\n* 设置模板路径，做主题包\r\n* 对其他包做插件\r\n* ...\r\n\r\n**钩子示例**\r\n\r\n记录全局请求日志 `/hook/app.init/log.php`\r\n```php\r\nuse Ebcms\\App;\r\nuse Ebcms\\Container;\r\nuse Monolog\\Handler\\StreamHandler;\r\nuse Monolog\\Logger;\r\nuse Psr\\Log\\LoggerInterface;\r\n\r\nApp::getInstance()->execute(function (\r\n    Container $container,\r\n    App $app\r\n) {\r\n    $container->set(LoggerInterface::class, function () use ($app): LoggerInterface {\r\n        $log = new Logger($_SERVER[\'HTTP_HOST\']);\r\n        $log->pushHandler(new StreamHandler($app->getAppPath() . \'/runtime/log/\' . date(\'Y-m-d\') . \'/debug.log\', Logger::DEBUG));\r\n        return $log;\r\n    });\r\n    $container->get(LoggerInterface::class)->debug($_SERVER[\'REQUEST_METHOD\'] . \':\' . $_SERVER[\'REQUEST_URI\'], [$_POST, $_GET]);\r\n});\r\n```\r\n\r\n给`plugin/demo`包自定义函数 `/hook/app.start@plugin.demo/functions.php`\r\n```php\r\nfunction test(): array\r\n{\r\n    return [];\r\n}\r\n```\r\n\r\n给`plugin/demo`包注入中间件 `/hook/app.start@plugin.demo/middleware_reg.php`\r\n```php\r\nuse Ebcms\\App;\r\nuse Ebcms\\RequestHandler;\r\n\r\nApp::getInstance()->execute(function (\r\n    RequestHandler $requestHandler,\r\n    App $app\r\n) {\r\n    $requestHandler->lazyMiddleware(SomeMiddleware::class);\r\n});\r\n```\r\n\r\n...还有很多，这里就不一一列举。', 0, 1610246238, 1614050980, 1, 4),
(66, 6, 0, 2, '配置', '', '', '## 文件结构\r\n\r\n```\r\ndemo\r\n├── src                                 // 资源\r\n│   ├── config                      // 配置\r\n│   │   ├── foo.php                     // 配置文件\r\n│   │   └── xxx.php                      // 配置文件\r\n```\r\n\r\n## 配置文件\r\n\r\n**foo.php**\r\n\r\n```php\r\n<?php \r\nreturn [\r\n    \'name\'=>\'示例\',\r\n    \'key\'=>[\'demo\', \'教学\'],\r\n];\r\n```\r\n\r\n## 获取配置\r\n\r\n```php\r\n$config->get(\'foo.name@plugin.demo\') // 示例\r\n$config->get(\'foo.key@plugin.demo\') // [\'demo\', \'教学\']\r\n```\r\n\r\n## 默认值\r\n\r\n```php\r\n$config->get(\'foo.somekey@plugin.demo\', \'默认值\') //默认值\r\n```', 0, 1610246243, 1613616547, 1, 6),
(67, 6, 0, 2, '数据库', '', '', '*数据库依赖于：<https://github.com/catfan/Medoo>，[中文文档](https://medoo.lvtao.net/)*\r\n\r\n系统对该数据库操作做了封装用于支持读写分离。\r\n\r\n```\r\nEbcms\\Database\\Db\r\n```\r\n\r\n获取实例：\r\n\r\n```\r\n$db->master(); // 获取master的medoo类\r\n$db->slave();// 获取slave的medoo类\r\n\r\n$db->instance($dbconfig);// 新实例化一个medoo类\r\n```\r\n\r\n具体的medoo类方法请参考medoo官方文档。', 0, 1610246416, 1614051639, 1, 3),
(71, 7, 0, 2, '授权协议', '', '', '***坚决抵制盗版系统，维护健康网络环境！***\r\n', 0, 1611384983, 1611621357, 1, 4),
(72, 7, 0, 2, '下载地址', '', '', '- [站长站](http://down.chinaz.com/soft/39233.htm)\r\n- [Github](https://github.com/ebcms/project-ebcms) (推荐)\r\n\r\n推荐github下载，那里有最新的，其他平台打包可能延迟哦', 0, 1611385003, 1611385819, 1, 3),
(73, 7, 0, 2, '用户手册', '', '', '整理中~', 0, 1611385015, 1611621367, 2, 2),
(74, 7, 0, 2, '开源地址', '', '', '本系统开源地址都统一在github平台\r\n\r\n<https://github.com/ebcms/project-ebcms>', 0, 1611385088, 1613741849, 1, 1),
(75, 7, 0, 2, '演示地址', '', '', ' #### 官方演示站\r\n \r\n- [前台](http://demo_ebcms.ebcms.com)\r\n- [后台](http://demo_ebcms.ebcms.com/ebcms/admin/index) 账号 admin 密码 123456\r\n\r\n#### 其他演示站\r\n\r\n欢迎投稿~', 0, 1611578998, 1611579233, 1, 0),
(100, 6, 0, 2, '控制器', '', '', '```php\r\n<?php\r\n\r\nnamespace App\\Plugin\\Demo\\Http;\r\n\r\nclass Index\r\n{\r\n    public function handle()\r\n    {\r\n        return \'Hello World!\';\r\n    }\r\n}\r\n```\r\n\r\n**注意：**\r\n\r\n控制器必须要有一个handle方法，ebcms和其他系统不一样，ebcms是路由到控制器而不是路由到控制器中的方法，路由到控制器后规定了执行handle方法\r\n\r\n**handle方法支持自动注入**\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Plugin\\Demo\\Http;\r\n\r\nuse Ebcms\\Config;\r\nuse Psr\\Log\\LoggerInterface;\r\n\r\nclass Index\r\n{\r\n    public function handle(\r\n        Config $config,\r\n        LoggerInterface $logger\r\n    ) {\r\n        // 记录日志\r\n        $logger->debug(\'访问index方法\');\r\n\r\n        $xxxx = $config->get(\'xxxx@plugin.demo\', \'默认值\');\r\n\r\n        return \'Hello World!\';\r\n    }\r\n}\r\n\r\n```', 0, 1613619756, 1614050166, 1, 7),
(101, 6, 0, 2, '中间件', '', '', '**中间件遵守标准的PSR规范！**\r\n\r\n中间件由`\\Ebcms\\RequestHandler`管理\r\n\r\n支持如下方法：\r\n\r\n* `middleware(MiddlewareInterface $middleware)` 注册一个中间件\r\n* `middlewares(array $middlewares)` 注册多个中间件\r\n* `prependMiddleware(MiddlewareInterface $middleware)` 注册一个中间件(顶部追加)\r\n* `lazyMiddleware(string $middleware)` 注册一个中间件(字符串形式、命名空间形式)\r\n* `lazyMiddlewares(array $middlewares)` 注册多个中间件(字符串形式、命名空间形式)\r\n* `lazyPrependMiddleware(string $middleware)` 注册一个中间件(字符串形式、命名空间形式)(顶部追加)\r\n\r\n**前置中间件**\r\n\r\n前置中间件就是在获得响应之前进行条件判断返回其他响应，主要是用作拦截，比如权限认证、跳转等等\r\n\r\n一个前置中间件的示例：\r\n\r\n```php\r\nuse Psr\\Http\\Message\\ResponseInterface;\r\nuse Psr\\Http\\Message\\ServerRequestInterface;\r\nuse Psr\\Http\\Server\\MiddlewareInterface;\r\nuse Psr\\Http\\Server\\RequestHandlerInterface;\r\n\r\nclass Auth implements MiddlewareInterface\r\n{\r\n    public function process(\r\n        ServerRequestInterface $request,\r\n        RequestHandlerInterface $handler\r\n    ): ResponseInterface {\r\n        if (\'未登录\') {\r\n            // 在响应之前返回跳转\r\n            return new JumpResponse(\'http://...\', 302);\r\n        }\r\n        return $handler->handle($request);\r\n    }\r\n}\r\n\r\n```\r\n\r\n**后置中间件**\r\n\r\n后置中间件主要是在获得响应后，对`响应`做变更，例如往响应的代码中注入代码，比如加入统计代码之类的。\r\n\r\n一个后置中间件的示例：\r\n\r\n```php\r\nuse Ebcms\\StreamFactory;\r\nuse Psr\\Http\\Message\\ServerRequestInterface;\r\nuse Psr\\Http\\Message\\ResponseInterface;\r\nuse Psr\\Http\\Server\\MiddlewareInterface;\r\nuse Psr\\Http\\Server\\RequestHandlerInterface;\r\n\r\nclass RejectTongjiCode implements MiddlewareInterface\r\n{\r\n\r\n    public function process(\r\n        ServerRequestInterface $request,\r\n        RequestHandlerInterface $handler\r\n    ): ResponseInterface {\r\n        $response = $handler->handle($request);\r\n        // 在响应之后，对响应注入其他代码\r\n        $tongji_code = \'<script>...</script>\';\r\n        $contents = str_replace(\'</body>\', $tongji_code . \'</body>\', $response->getBody());\r\n        return $response->withBody((new StreamFactory())->createStream($contents));\r\n    }\r\n}\r\n\r\n```\r\n\r\n*前置中间件和后置中间件的代码区别就是前置是在`$handler->handle($request)`处理之前返回其他`响应`，后置是在获取`$handler->handle($request)`响应之后对`响应`做出处理*\r\n\r\n**将中间件注入到系统**\r\n\r\n注入到系统中有很多方式，比如在钩子上注入，也可以在控制器中注入，也可以在路由上注入\r\n\r\n**通过钩子注入示例**\r\n\r\n```php\r\n// /hook/app.start/aaa.php\r\nuse Ebcms\\App;\r\nuse Ebcms\\RequestHandler;\r\n\r\nApp::getInstance()->execute(function (\r\n    RequestHandler $requestHandler\r\n) {\r\n    $requestHandler->lazyMiddleware(SomeMiddleware::class);\r\n});\r\n```\r\n\r\n**在控制器中注入示例**\r\n\r\n```php\r\nuse Ebcms\\RequestHandler;\r\n\r\nclass Index\r\n{\r\n    public function __construct(\r\n        RequestHandler $requestHandler\r\n    ) {\r\n        $requestHandler->lazyMiddleware(SomeMiddleware::class);\r\n    }\r\n}\r\n```\r\n\r\n**通过路由注入**\r\n\r\n参考路由', 0, 1614048811, 1614048928, 1, 1),
(102, 6, 0, 2, '依赖注入', '', '', '**容器类`\\Ebcms\\Container`**\r\n\r\n**依赖注入来自开源项目[ebcms/psr11](https://github.com/ebcms/psr11)，欢迎PR ^-^.**\r\n\r\n依赖注入的好处就是可以全局管理类，无须手动实例化。\r\n\r\n**自动实例化类**\r\n\r\n```php\r\nclass Bar\r\n{\r\n    public function __construct()\r\n    {\r\n    }\r\n}\r\n\r\nclass Foo\r\n{\r\n    public function __construct(Bar $bar)\r\n    {\r\n        $this->bar = $bar;\r\n    }\r\n    \r\n    public function getBar()\r\n    {\r\n        return $this->bar;\r\n    }\r\n}\r\n\r\n$foo = $container->get(Foo::class); //Foo\r\n$foo->getBar(); //Bar\r\n```\r\n\r\n而无须实例化Foo类，也不需要实例化Bar类，这一切都通过$container帮您完成。\r\n\r\n**默认的，执行的控制器的构造方法`__construct()`支持依赖注入，例如：**\r\n\r\n```php\r\nuse Ebcms\\App;\r\nuse Ebcms\\Config;\r\nuse Ebcms\\Router;\r\nuse Xielei\\Template;\r\n\r\nclass Index\r\n{\r\n    public function __construct(\r\n        App $app,\r\n        Router $router,\r\n        Config $config,\r\n        Template $template,\r\n        ...\r\n    ) {\r\n        $config->get(......);\r\n        $router->build(..);\r\n    }\r\n}\r\n```\r\n\r\n**通过容器获取的类支持依赖注入，例如：**\r\n\r\n```php\r\n$container->get(Foo::class);\r\n```\r\n\r\n那么 此处的Foo类的构造函数就可以依赖注入\r\n\r\n**通过`App::getInstrance()->execute(function(...){})`实现依赖注入，例如：**\r\n\r\n```php\r\nApp::getInstance()->execute(function (\r\n    App $app,\r\n    RequestHandler $requestHandler,\r\n    RequestFilter $input,\r\n    Router $router,\r\n    Config $config,\r\n    Template $template,\r\n    ....\r\n) {\r\n    $app->....\r\n});\r\n```\r\n', 0, 1614049086, 1614049164, 1, 0),
(103, 6, 0, 2, '模型', '', '', '**模型无需继承任何类**\r\n\r\n实现数据库读写操作，推荐继承 `Ebcms\\Database\\Model`\r\n\r\n继承该类后，就支持：\r\n\r\n| 方法 | 说明 |\r\n| -------- | -------- |\r\n| get     | 获取单条数据     |\r\n| has     | 判断数据是否存在     |\r\n| select     | 获取多条数据     |\r\n| insert     | 插入数据     |\r\n| update     | 更新     |\r\n| delete     | 删除     |\r\n| replace     | 字段替换     |\r\n| id     | 获取插入的id     |\r\n| rand     | 随机获取     |\r\n| count     | 计数     |\r\n| max     | 最大值     |\r\n| min     | 最小值     |\r\n| avg     | 平均值     |\r\n| sum     | 求和     |\r\n\r\n具体的参数请看编辑器代码提示', 0, 1614051652, 1614052305, 1, 2),
(104, 8, 0, 2, '特性', '', '', '### 基于swoole4开发\r\n\r\nswoole是...\r\n\r\n### 基于Gateway、Worker进程模型\r\n\r\ngate..\r\n\r\n### 支持分布式部署\r\n\r\n...\r\n\r\n### 支持高并发\r\n\r\n...\r\n\r\n### 支持全局广播或者向任意客户端推送数据\r\n\r\n。。。\r\n\r\n### 支持各种应用层协议\r\n\r\n。。。\r\n\r\n### 支持自定义协议\r\n\r\n。。。\r\n\r\n### 高性能\r\n\r\n。。。\r\n\r\n### 方便与其他项目集成\r\n\r\n。。。', 0, 1618924266, 1619513477, 2, 9),
(105, 8, 0, 2, '工作原理', '', '', '采用经典的gateway-worker模型。。\r\n\r\n### 原理图\r\n\r\n![http://www.ebcms.com/uploads/2021/04-27/6087c1f10c381.png](http://www.ebcms.com/uploads/2021/04-27/6087c1f10c381.png)\r\n\r\n### 工作流程\r\n\r\n1、Register、Gateway、BusinessWorker进程启动\r\n\r\n2、Gateway、Worker进程启动后均会向Register服务进程发起长连接注册自己\r\n\r\n3、Register服务收到Gateway的注册后，把所有Gateway的通讯地址保存在内存中\r\n\r\n4、Register服务收到Worker的注册后，把内存中所有的Gateway的通讯地址发给Worker\r\n\r\n5、Worker进程得到所有的Gateway内部通讯地址后尝试连接Gateway\r\n\r\n6、如果运行过程中有新的Gateway服务注册到Register（一般是分布式部署加机器），则将新的Gateway内部通讯地址列表将广播给所有Worker，Worker收到后建立连接\r\n\r\n7、如果有Gateway下线，则Register服务会收到通知，会将对应的内部通讯地址删除，然后广播新的内部通讯地址列表给所有Worker，Worker不再连接下线的Gateway\r\n\r\n8、至此Gateway与Worker通过Register已经建立起长连接\r\n\r\n9、客户端的事件及数据全部由Gateway转发给Worker处理，Worker中的onConnect onMessage onClose..处理业务逻辑。\r\n\r\n10、整个系统的业务逻辑完全在Worker中，包括onWorkerStart进程启动事件(进程事件)、onConnect连接事件(客户端事件)、onMessage消息事件（客户端事件）、onClose连接关闭事件（客户端事件）、onWorkerStop进程退出事件（进程事件），无须关心Register和Gateway', 0, 1618924287, 1619511302, 1, 8),
(106, 8, 0, 2, 'Register用法', '', '', '## 基本用法\r\n```php\r\n<?php\r\n\r\nuse Xielei\\Swoole\\Register;\r\n\r\nrequire_once __DIR__ . \'/vendor/autoload.php\';\r\n\r\n$register = new Register(\'127.0.0.1\', 3327);\r\n\r\n$register->secret_key = \'this is secret_key..\';\r\n\r\n$register->start();\r\n```\r\n\r\n若所有进程都在一台服务器上，那么地址就填写`127.0.0.1`，否则就填`内网ip`。\r\n\r\n只支持ipv4，若非必要**不要填`0.0.0.0`或者`公网ip`**\r\n\r\n`secret_key`是通讯密钥，`gateway`和`worker`要连接上`register`，就必须填写这个密钥', 0, 1618924350, 1619510519, 1, 6),
(107, 8, 0, 2, 'Gateway用法', '', '', '## 基本用法\r\n\r\n``` php\r\n<?php\r\n\r\nuse Xielei\\Swoole\\Gateway;\r\n\r\nrequire_once __DIR__ . \'/vendor/autoload.php\';\r\n\r\n$gateway = new Gateway(\'127.0.0.1\', 8000);\r\n\r\n$gateway->lan_host = \'127.0.0.1\';\r\n$gateway->lan_port_start = 7777;\r\n\r\n$gateway->register_host = \'127.0.0.1\';\r\n$gateway->register_secret_key = \'this is secret_key..\';\r\n\r\n$gateway->start();\r\n```\r\n\r\n#### 启用`websocket`协议\r\n\r\n``` php\r\n$gateway->set([\r\n    \'open_websocket_protocol\' => true,\r\n    \'open_websocket_close_frame\' => true,\r\n]);\r\n```\r\n\r\n#### 自定义协议\r\n\r\n**前四个字节是包长度：**\r\n``` php\r\n$gateway->set([\r\n    \'open_length_check\' => true,\r\n    \'package_length_type\' => \'N\',\r\n    \'package_length_offset\' => 0,\r\n    \'package_body_offset\' => 0,\r\n]);\r\n```\r\n\r\n**换行符分割：**\r\n``` php\r\n$gateway->set([\r\n    \'open_eof_split\' => true,\r\n    \'package_eof\'    => \"\\r\\n\",\r\n]);\r\n```\r\n\r\n> 更灵活的自定义协议请加群讨论\r\n\r\n#### 多进程服务\r\n\r\n``` php\r\n$gateway->set([\r\n    \'worker_num\' => 3,\r\n]);\r\n```\r\n\r\n#### 守护进程运行\r\n\r\n``` php\r\n$gateway->set([\r\n    \'daemonize\' => true,\r\n]);\r\n```', 0, 1618924356, 1619513431, 1, 5);
INSERT INTO `prefix_ebcms_book_post` (`id`, `book_id`, `pid`, `type`, `title`, `keywords`, `description`, `body`, `click`, `create_time`, `update_time`, `state`, `rank`) VALUES
(108, 8, 0, 2, 'Worker用法', '', '', '## 基本用法\r\n\r\n``` php\r\n<?php\r\n\r\nuse Xielei\\Swoole\\Worker;\r\n\r\nrequire_once __DIR__ . \'/vendor/autoload.php\';\r\n\r\n$worker = new Worker($event, 2);\r\n\r\n$worker->register_host = \'127.0.0.1\';\r\n$worker->register_secret_key = \'this is secret_key..\';\r\n\r\n$worker->start();\r\n```\r\n\r\n> 第一个参数是工作类实例，必须继承`\\Xielei\\Swoole\\Event`，第二个参数是工作进程数量，一般填写cpu核数\r\n\r\n## Event类示例\r\n\r\n``` php\r\n<?php\r\n\r\nuse Swoole\\Process\\Pool;\r\nuse Xielei\\Swoole\\Event as SwooleEvent;\r\n\r\nclass Event extends SwooleEvent\r\n{\r\n    public function onWorkerStart(Pool $pool, int $worker_id)\r\n    {\r\n        echo \"进程开始\\n\";\r\n    }\r\n\r\n    public function onWebsocketConnect(string $client, array $global)\r\n    {\r\n        echo \"{$client} websocket连接\\n\";\r\n    }\r\n\r\n    public function onConnect(string $client)\r\n    {\r\n        echo \"{$client} 连接\\n\";\r\n    }\r\n\r\n    public function onMessage(string $client, string $data)\r\n    {\r\n        echo \"收到来自 {$client} 的消息，消息内容是：{$data}\\n\";\r\n    }\r\n\r\n    public function onClose(string $client)\r\n    {\r\n        echo \"{$client} 断开\\n\";\r\n    }\r\n\r\n    public function onWorkerStop(Pool $pool, int $worker_id)\r\n    {\r\n        echo \"进程关闭\\n\";\r\n    }\r\n}\r\n```\r\n\r\n在`onWebsocketConnect`、`onConnect`、`onMessage`、`onClose`四个回调方法中可以直接使用`$_SESSION`全局变量，即当前客户端的session数据\r\n\r\n此session不同于常规session，无需session_start', 0, 1618924363, 1619515802, 1, 4),
(109, 8, 0, 1, '接口', '', '', NULL, 0, 1618924447, 1618924449, 1, 3),
(110, 8, 109, 2, 'sendToClient', '', '', '``` php\r\n/**\r\n * 给客户端发消息\r\n *\r\n * @param string $client 客户端\r\n * @param string $message 消息内容\r\n * @return void\r\n */\r\npublic static function sendToClient(string $client, string $message)\r\n```', 0, 1618924464, 1619511509, 1, 35),
(111, 8, 109, 2, 'sendToUid', '', '', '``` php\r\n/**\r\n * 给绑定了指定uid的客户端发消息\r\n *\r\n * @param string $uid uid\r\n * @param string $message 消息内容\r\n * @return void\r\n */\r\npublic static function sendToUid(string $uid, string $message)\r\n```', 0, 1618924471, 1619511531, 1, 34),
(112, 8, 109, 2, 'sendToGroup', '', '', '```php\r\n/**\r\n * 给指定分组下的所有客户端发消息\r\n *\r\n * @param string $group 组名称\r\n * @param string $message 消息内容\r\n * @param array $without_client_list 要排除的客户端\r\n * @return void\r\n */\r\npublic static function sendToGroup(string $group, string $message, array $without_client_list = [])\r\n```', 0, 1618924496, 1619511551, 1, 33),
(113, 8, 109, 2, 'sendToAll', '', '', '```php\r\n/**\r\n * 给所有客户端发消息\r\n *\r\n * @param string $message 发送的内容\r\n * @param array $without_client_list 要排除的客户端\r\n * @return void\r\n */\r\npublic static function sendToAll(string $message, array $without_client_list = [])\r\n```', 0, 1618924530, 1619511567, 1, 32),
(114, 8, 109, 2, 'isOnline', '', '', '```php\r\n/**\r\n * 判断指定客户端是否在线\r\n *\r\n * @param string $client\r\n * @return boolean\r\n */\r\npublic static function isOnline(string $client)\r\n```', 0, 1618924558, 1619511587, 1, 31),
(115, 8, 109, 2, 'isUidOnline', '', '', '``` php\r\n/**\r\n * 判断指定uid是否在线\r\n *\r\n * @param string $uid\r\n * @return boolean\r\n */\r\npublic static function isUidOnline(string $uid): bool\r\n```', 0, 1618924571, 1619511607, 1, 30),
(116, 8, 109, 2, 'getClientListByGroup', '', '', '``` php\r\n/**\r\n * 获取指定分组下的客户列表\r\n *\r\n * @param string $group 分组名称\r\n * @param string $prev_client 从该客户端开始读取\r\n * @return iterable\r\n */\r\npublic static function getClientListByGroup(string $group, string $prev_client = null): iterable\r\n```', 0, 1618924585, 1619511628, 1, 29),
(117, 8, 109, 2, 'getClientCount', '', '', '``` php\r\n/**\r\n * 获取所有客户端数量\r\n *\r\n * @return integer\r\n */\r\npublic static function getClientCount(): int\r\n```', 0, 1618924598, 1619511797, 1, 28),
(118, 8, 109, 2, 'getClientCountByGroup', '', '', '``` php\r\n/**\r\n * 获取指定分组下的客户端数量\r\n *\r\n * @param string $group\r\n * @return integer\r\n */\r\npublic static function getClientCountByGroup(string $group): int\r\n```', 0, 1618924611, 1619511813, 1, 27),
(119, 8, 109, 2, 'getClientList', '', '', '``` php\r\n/**\r\n * 获取客户端列表\r\n *\r\n * @param string $prev_client 从该客户端开始读取\r\n * @return iterable\r\n */\r\npublic static function getClientList(string $prev_client = null): iterable\r\n```', 0, 1618924624, 1619511826, 1, 26),
(120, 8, 109, 2, 'getClientListByUid', '', '', '``` php\r\n/**\r\n * 获取某个uid下绑定的客户端列表\r\n *\r\n * @param string $uid\r\n * @param string $prev_client 从该客户但开始读取\r\n * @return iterable\r\n */\r\npublic static function getClientListByUid(string $uid, string $prev_client = null): iterable\r\n```', 0, 1618924633, 1619511838, 1, 25),
(121, 8, 109, 2, 'getClientInfo', '', '', '``` php\r\n/**\r\n * 获取客户信息\r\n *\r\n * @param string $client 客户端\r\n * @param integer $type 具体要获取哪些数据，默认全部获取，也可按需获取，可选参数：Xielei\\Swoole\\Protocol::CLIENT_INFO_UID(绑定的uid) | Xielei\\Swoole\\Protocol::CLIENT_INFO_SESSION(session) | Xielei\\Swoole\\Protocol::CLIENT_INFO_GROUP_LIST(绑定的分组列表) | Xielei\\Swoole\\Protocol::CLIENT_INFO_TAG_LIST（绑定的标签列表） | Xielei\\Swoole\\Protocol::CLIENT_INFO_REMOTE_IP（客户ip） | Xielei\\Swoole\\Protocol::CLIENT_INFO_REMOTE_PORT（客户端口） | Xielei\\Swoole\\Protocol::CLIENT_INFO_SYSTEM（客户系统信息）\r\n * @return array\r\n */\r\npublic static function getClientInfo(string $client, int $type = 255): array\r\n```\r\n\r\n**只获取客户绑定的分组**\r\n\r\n``` php\r\nApi::getClientInfo($client, Xielei\\Swoole\\Protocol::CLIENT_INFO_GROUP_LIST);\r\n```\r\n\r\n**同时获取绑定uid和session数据**\r\n\r\n``` php\r\nApi::getClientInfo($client, Xielei\\Swoole\\Protocol::CLIENT_INFO_UID | Xielei\\Swoole\\Protocol::CLIENT_INFO_SESSION);\r\n```\r\n\r\n**获取客户端ip**\r\n\r\n``` php\r\nApi::getClientInfo($client, Xielei\\Swoole\\Protocol::CLIENT_INFO_REMOTE_IP);\r\n```', 0, 1618924646, 1619513876, 1, 24),
(122, 8, 109, 2, 'getUidListByGroup', '', '', '``` php\r\n/**\r\n * 获取指定分组下客户绑定的uid列表\r\n *\r\n * @param string $group 分组名称\r\n * @param boolean $unique 是否过滤重复值 默认过滤，若用户数过多，会占用较大内存，建议根据需要设置\r\n * @return iterable\r\n */\r\npublic static function getUidListByGroup(string $group, bool $unique = true): iterable\r\n```', 0, 1618924653, 1619511870, 1, 23),
(123, 8, 109, 2, 'getUidList', '', '', '``` php\r\n/**\r\n * 获取所有uid列表\r\n *\r\n * @param boolean $unique 是否过滤重复值 默认过滤，若用户数过多，会占用较大内存，建议根据需要设置\r\n * @return iterable\r\n */\r\npublic static function getUidList(bool $unique = true): iterable\r\n```', 0, 1618924667, 1619511886, 1, 22),
(124, 8, 0, 1, '常见问题', '', '', NULL, 0, 1618924764, 1618924766, 1, 1),
(125, 8, 124, 2, '关于client', '', '', 'client固定为20个字符的字符串，用来全局标记一个socket连接，每个客户端连接都会被分配一个全局唯一的client。\r\n\r\nclient不能自定义，由GatewayWorker自动生成。\r\n\r\n如果client对应的客户端连接断开了，那么这个client也就失效了。当这个客户端再次连接到Gateway时，将会获得一个新的client。也就是说client和客户端的socket连接生命周期是一致的。\r\n\r\nclient一旦被使用过，将不会被再次使用，也就是说client是不会重复的，即使分布式部署也不会重复。\r\n\r\n只要有client，并且对应的客户端在线，就可以调用Gateway::sendToClient($client, $data)等方法向这个客户端发送数据。', 0, 1618924771, 1619514058, 1, 3),
(126, 8, 124, 2, '开启多少进程', '', '', NULL, 0, 1618924792, 1619514078, 2, 2),
(127, 8, 124, 2, '多协议支持', '', '', NULL, 0, 1618924799, 1619514077, 2, 1),
(128, 8, 0, 1, '分布式部署', '', '', NULL, 0, 1618924828, 1618924829, 1, 2),
(129, 8, 0, 2, '安装', '', '', '本框架基于swoole开发，所以，请先确保你已经安装了[swoole](https://www.swoole.com)\r\n\r\n1.通过composer安装：\r\n\r\n```\r\ncomposer require xielei/swoole-worker\r\n```\r\n\r\n2.通过其他方式\r\n\r\n不推荐。。', 0, 1618925090, 1619512680, 1, 7),
(130, 8, 109, 2, 'getUidCount', '', '', '``` php\r\n/**\r\n * 获取绑定的uid总数（该数据只是一个近似值），一个uid可能被多个gateway下的客户端绑定，考虑性能原因，并不计算精确值，在不传百分比的情况下，系统会自动计算一个近似百分比，通过该百分比计算出近似的总uid数\r\n *\r\n * @param float $unique_percent 唯一百分比，例如：80%。若知道的情况下请尽量填写，这样数据更加准确。\r\n * @return integer\r\n */\r\npublic static function getUidCount(float $unique_percent = null): int\r\n```', 0, 1618925155, 1619511902, 1, 21),
(131, 8, 109, 2, 'getGroupList', '', '', '``` php\r\n/**\r\n * 获取分组列表\r\n *\r\n * @param boolean $unique 是否去除重复数据，默认去除，若分组数据较多（例如百万级别），会占用很大的内存，若能够在业务上处理，请尽量设置为false\r\n * @return iterable\r\n */\r\npublic static function getGroupList(bool $unique = true): iterable\r\n```', 0, 1618925166, 1619511917, 1, 20),
(132, 8, 109, 2, 'getUidCountByGroup', '', '', '``` php\r\n/**\r\n * 获取指定分组下的用户数\r\n *\r\n * @param string $group 分组名称\r\n * @return integer\r\n */\r\npublic static function getUidCountByGroup(string $group): int\r\n```', 0, 1618925174, 1619511927, 1, 19),
(133, 8, 109, 2, 'closeClient', '', '', '``` php\r\n/**\r\n * 关闭客户端\r\n *\r\n * @param string $client 客户端\r\n * @param boolean $force 是否强制关闭，强制关闭会立即关闭客户端，不会等到待发送数据发送完毕就立即关闭\r\n * @return void\r\n */\r\npublic static function closeClient(string $client, bool $force = false)\r\n```', 0, 1618925183, 1619511942, 1, 18),
(134, 8, 109, 2, 'bindUid', '', '', '``` php\r\n/**\r\n * 绑定uid 一个客户端只能绑定一个uid，多次绑定只以最后一个为准，客户端下线会自动解绑，无需手动解绑\r\n *\r\n * @param string $client\r\n * @param string $uid\r\n * @return void\r\n */\r\npublic static function bindUid(string $client, string $uid)\r\n```', 0, 1618925190, 1619514354, 1, 17),
(135, 8, 109, 2, 'unBindUid', '', '', '``` php\r\n/**\r\n * 取消绑定uid\r\n *\r\n * @param string $client\r\n * @return void\r\n */\r\npublic static function unBindUid(string $client)\r\n```', 0, 1618925199, 1619511963, 1, 16),
(136, 8, 109, 2, 'joinGroup', '', '', '``` php\r\n/**\r\n * 客户端加入到指定分组 客户断开会自动从加入的分组移除，无需手动处理\r\n *\r\n * @param string $client 客户端\r\n * @param string $group 分组名称\r\n * @return void\r\n */\r\npublic static function joinGroup(string $client, string $group)\r\n```', 0, 1618925206, 1619511975, 1, 15),
(137, 8, 109, 2, 'leaveGroup', '', '', '``` php\r\n/**\r\n * 将客户端从指定分组移除\r\n *\r\n * @param string $client 客户端\r\n * @param string $group 指定分组\r\n * @return void\r\n */\r\npublic static function leaveGroup(string $client, string $group)\r\n```', 0, 1618925214, 1619511987, 1, 14),
(138, 8, 109, 2, 'unGroup', '', '', '``` php\r\n/**\r\n * 解散分组\r\n *\r\n * @param string $group 分组名称\r\n * @return void\r\n */\r\npublic static function unGroup(string $group)\r\n```', 0, 1618925224, 1619512000, 1, 13),
(139, 8, 109, 2, 'setSession', '', '', '``` php\r\n/**\r\n * 设置session 直接替换session\r\n *\r\n * @param string $client 客户端\r\n * @param array $session session数据\r\n * @return void\r\n */\r\npublic static function setSession(string $client, array $session)\r\n```', 0, 1618925233, 1619512013, 1, 12),
(140, 8, 109, 2, 'updateSession', '', '', '``` php\r\n/**\r\n * 更新指定客户端session 区别于设置session，设置是直接替换，更新会合并旧数据\r\n *\r\n * @param string $client\r\n * @param array $session\r\n * @return void\r\n */\r\npublic static function updateSession(string $client, array $session)\r\n```', 0, 1618925241, 1619512023, 1, 11),
(141, 8, 109, 2, 'deleteSession', '', '', '``` php\r\n/**\r\n * 删除指定客户端的session\r\n *\r\n * @param string $client\r\n * @return void\r\n */\r\npublic static function deleteSession(string $client)\r\n```', 0, 1618925247, 1619512032, 1, 10),
(142, 8, 109, 2, 'getSession', '', '', '``` php\r\n/**\r\n * 获取指定客户端session\r\n *\r\n * @param string $client\r\n * @return array|null\r\n */\r\npublic static function getSession(string $client): ?array\r\n```', 0, 1618925254, 1619512046, 1, 9),
(143, 8, 109, 2, 'sendToAddressAndRecv', '', '', '``` php\r\n/**\r\n * 向指定地址发送数据后返回数据\r\n *\r\n * @param array $address 指定地址\r\n * @param string $buffer 发送的数据\r\n * @param integer $timeout 超时时间 单位秒 支持浮点数\r\n * @return string\r\n */\r\npublic static function sendToAddressAndRecv(array $address, string $buffer, $timeout = 1): string\r\n```', 0, 1618925260, 1619512069, 1, 7),
(144, 8, 109, 2, 'sendToAddress', '', '', '``` php\r\n/**\r\n * 向指定地址发送数据\r\n *\r\n * @param array $address 指定地址\r\n * @param string $buffer 数据\r\n * @param integer $timeout 超时时间，单位秒，支持浮点数\r\n * @return void\r\n */\r\npublic static function sendToAddress(array $address, string $buffer, $timeout = 1)\r\n```', 0, 1618925267, 1619512083, 1, 6),
(145, 8, 109, 1, 'group', '', '', NULL, 0, 1618925294, 1618925729, 2, 5),
(146, 8, 109, 2, 'sendToAddressListAndRecv', '', '', '``` php\r\n/**\r\n * 向多个地址发送数据并批量接收\r\n *\r\n * @param array $items\r\n * @param float $timeout 超时时间 单位秒\r\n * @return array\r\n */\r\npublic static function sendToAddressListAndRecv(array $items, float $timeout = 1): array\r\n```', 0, 1618925397, 1619512177, 1, 8),
(147, 8, 109, 2, 'getTagList', '', '', '``` php\r\n\r\n```', 0, 1618925422, 1619512220, 2, 4),
(148, 8, 109, 2, 'sendToAllByTag', '', '', '``` php\r\n\r\n```', 0, 1618925488, 1619512221, 2, 3),
(149, 8, 109, 2, 'unBindTag', '', '', '``` php\r\n\r\n```', 0, 1618925525, 1619512222, 2, 2),
(150, 8, 109, 2, 'deleteTag', '', '', '``` php\r\n\r\n```', 0, 1618925560, 1619512223, 2, 1),
(151, 8, 109, 2, 'getClientCountByTag', '', '', '``` php\r\n\r\n```', 0, 1618925579, 1619512224, 2, 0),
(152, 8, 124, 2, '绑定uid group tag三者的区别', '', '', '一个客户端只能绑定一个uid，一个uid可以被多个客户端绑定，（例如qq的多端登陆）\r\n\r\n一个客户端可以绑定多个group，一个group可以被多个客户端绑定，（例如群）\r\n\r\n一个客户端可以绑定多个tag，一个tag可以被多个客户端绑定，（分组广播）\r\n\r\n这里的group和tag有相似的地方，不过用法不一样，一个group通常不会绑定很多客户端，参考qq群，一般2000个算比较多，所以group相关的接口比较丰富\r\n\r\n而tag主要用于广播，相关接口较少', 0, 1618925655, 1619514081, 2, 0),
(153, 8, 128, 2, 'Worker动态扩容', '', '', NULL, 0, 1618925684, 1618925709, 1, 1),
(154, 8, 128, 2, 'Gateway动态扩容', '', '', NULL, 0, 1618925699, 1618925710, 1, 0),
(155, 8, 0, 2, 'Swoole官网', '', '', '官网:https://www.swoole.com/\r\n\r\nSwoole文档:https://wiki.swoole.com/', 0, 1618925766, 1618925886, 1, 0);
str;
    }

    private static function getUninstallSql(): string
    {
        return <<<'str'
DROP TABLE IF EXISTS `prefix_ebcms_book_book`;
DROP TABLE IF EXISTS `prefix_ebcms_book_post`;
str;
    }
}
